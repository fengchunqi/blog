<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试-Vue | frenchleave</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="冯春齐 fengchunqi frenchleave blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="keywords" content="冯春齐,fengchunqi,frenchleave blog">
    
    <link rel="preload" href="/assets/css/0.styles.615f1c30.css" as="style"><link rel="preload" href="/assets/js/app.a4a1bf2e.js" as="script"><link rel="preload" href="/assets/js/3.83a3aa92.js" as="script"><link rel="preload" href="/assets/js/1.1efd4ac0.js" as="script"><link rel="preload" href="/assets/js/63.48e809fc.js" as="script"><link rel="preload" href="/assets/js/11.a144a0bb.js" as="script"><link rel="prefetch" href="/assets/js/10.4c13b9ab.js"><link rel="prefetch" href="/assets/js/100.aaeda1f9.js"><link rel="prefetch" href="/assets/js/101.130bb8fc.js"><link rel="prefetch" href="/assets/js/102.1acb4651.js"><link rel="prefetch" href="/assets/js/103.fa28f9dc.js"><link rel="prefetch" href="/assets/js/104.3947688a.js"><link rel="prefetch" href="/assets/js/105.fdb69d3b.js"><link rel="prefetch" href="/assets/js/106.1f0943a4.js"><link rel="prefetch" href="/assets/js/107.01add185.js"><link rel="prefetch" href="/assets/js/108.1b5134bb.js"><link rel="prefetch" href="/assets/js/109.c038c06c.js"><link rel="prefetch" href="/assets/js/110.46ba7d27.js"><link rel="prefetch" href="/assets/js/111.865d2bb5.js"><link rel="prefetch" href="/assets/js/112.3086e8d4.js"><link rel="prefetch" href="/assets/js/113.d801577d.js"><link rel="prefetch" href="/assets/js/114.5215165b.js"><link rel="prefetch" href="/assets/js/115.2f762218.js"><link rel="prefetch" href="/assets/js/116.13b7ec21.js"><link rel="prefetch" href="/assets/js/117.9696b606.js"><link rel="prefetch" href="/assets/js/118.5dae0379.js"><link rel="prefetch" href="/assets/js/119.a886448a.js"><link rel="prefetch" href="/assets/js/12.aacff449.js"><link rel="prefetch" href="/assets/js/120.e28722d4.js"><link rel="prefetch" href="/assets/js/121.d2e7cddb.js"><link rel="prefetch" href="/assets/js/122.f25871c4.js"><link rel="prefetch" href="/assets/js/123.d4928f1d.js"><link rel="prefetch" href="/assets/js/124.61eeb6cd.js"><link rel="prefetch" href="/assets/js/125.35cb65b3.js"><link rel="prefetch" href="/assets/js/126.371a35b1.js"><link rel="prefetch" href="/assets/js/127.a4bcc839.js"><link rel="prefetch" href="/assets/js/128.f7234d36.js"><link rel="prefetch" href="/assets/js/129.9910dae6.js"><link rel="prefetch" href="/assets/js/13.35fa9aaa.js"><link rel="prefetch" href="/assets/js/130.18d477b9.js"><link rel="prefetch" href="/assets/js/131.90f6a168.js"><link rel="prefetch" href="/assets/js/132.c0267ef1.js"><link rel="prefetch" href="/assets/js/133.76b44eb0.js"><link rel="prefetch" href="/assets/js/134.25db4601.js"><link rel="prefetch" href="/assets/js/135.3446af8a.js"><link rel="prefetch" href="/assets/js/136.3cf03a86.js"><link rel="prefetch" href="/assets/js/137.6c705f5b.js"><link rel="prefetch" href="/assets/js/138.ef296ddf.js"><link rel="prefetch" href="/assets/js/139.829c2256.js"><link rel="prefetch" href="/assets/js/14.cb43ec9e.js"><link rel="prefetch" href="/assets/js/140.04d38cac.js"><link rel="prefetch" href="/assets/js/141.cbb3defa.js"><link rel="prefetch" href="/assets/js/142.1e9cada1.js"><link rel="prefetch" href="/assets/js/143.704f14d7.js"><link rel="prefetch" href="/assets/js/15.51e59a06.js"><link rel="prefetch" href="/assets/js/16.181c0fea.js"><link rel="prefetch" href="/assets/js/17.82323cc3.js"><link rel="prefetch" href="/assets/js/18.f31a0c3d.js"><link rel="prefetch" href="/assets/js/19.0cd78688.js"><link rel="prefetch" href="/assets/js/20.f4f125db.js"><link rel="prefetch" href="/assets/js/21.88dd7d6a.js"><link rel="prefetch" href="/assets/js/22.ef435564.js"><link rel="prefetch" href="/assets/js/23.78c23cf1.js"><link rel="prefetch" href="/assets/js/24.e01d16e5.js"><link rel="prefetch" href="/assets/js/25.0ec5c7df.js"><link rel="prefetch" href="/assets/js/26.4ccdcb29.js"><link rel="prefetch" href="/assets/js/27.5b4793aa.js"><link rel="prefetch" href="/assets/js/28.85630f33.js"><link rel="prefetch" href="/assets/js/29.89fda983.js"><link rel="prefetch" href="/assets/js/30.d7b9cb5f.js"><link rel="prefetch" href="/assets/js/31.30d92504.js"><link rel="prefetch" href="/assets/js/32.d036e909.js"><link rel="prefetch" href="/assets/js/33.a90fc05f.js"><link rel="prefetch" href="/assets/js/34.7d3fa6cd.js"><link rel="prefetch" href="/assets/js/35.81fb7904.js"><link rel="prefetch" href="/assets/js/36.92280a7f.js"><link rel="prefetch" href="/assets/js/37.2a5e653d.js"><link rel="prefetch" href="/assets/js/38.a4f8f0ba.js"><link rel="prefetch" href="/assets/js/39.68d86d43.js"><link rel="prefetch" href="/assets/js/4.eced67fa.js"><link rel="prefetch" href="/assets/js/40.d20bee83.js"><link rel="prefetch" href="/assets/js/41.eb1bc5dd.js"><link rel="prefetch" href="/assets/js/42.13c35568.js"><link rel="prefetch" href="/assets/js/43.c575441a.js"><link rel="prefetch" href="/assets/js/44.a5a7840d.js"><link rel="prefetch" href="/assets/js/45.84d8c0fe.js"><link rel="prefetch" href="/assets/js/46.5eecf097.js"><link rel="prefetch" href="/assets/js/47.9f9e4450.js"><link rel="prefetch" href="/assets/js/48.014d2d67.js"><link rel="prefetch" href="/assets/js/49.06c47865.js"><link rel="prefetch" href="/assets/js/5.56199536.js"><link rel="prefetch" href="/assets/js/50.17e9b59f.js"><link rel="prefetch" href="/assets/js/51.d8d95c41.js"><link rel="prefetch" href="/assets/js/52.c4b3038c.js"><link rel="prefetch" href="/assets/js/53.489453a8.js"><link rel="prefetch" href="/assets/js/54.70064a5c.js"><link rel="prefetch" href="/assets/js/55.8c34d0bd.js"><link rel="prefetch" href="/assets/js/56.10e78219.js"><link rel="prefetch" href="/assets/js/57.a550cc66.js"><link rel="prefetch" href="/assets/js/58.bb1a57f1.js"><link rel="prefetch" href="/assets/js/59.da3fa553.js"><link rel="prefetch" href="/assets/js/6.36581b04.js"><link rel="prefetch" href="/assets/js/60.799282eb.js"><link rel="prefetch" href="/assets/js/61.0b10441d.js"><link rel="prefetch" href="/assets/js/62.ae4ae9bd.js"><link rel="prefetch" href="/assets/js/64.d8cc7fdf.js"><link rel="prefetch" href="/assets/js/65.95b17d60.js"><link rel="prefetch" href="/assets/js/66.0830362b.js"><link rel="prefetch" href="/assets/js/67.a0b450d0.js"><link rel="prefetch" href="/assets/js/68.6853b27f.js"><link rel="prefetch" href="/assets/js/69.b853dcff.js"><link rel="prefetch" href="/assets/js/7.d48afba3.js"><link rel="prefetch" href="/assets/js/70.05ec6e98.js"><link rel="prefetch" href="/assets/js/71.c8ebe81d.js"><link rel="prefetch" href="/assets/js/72.4b717acd.js"><link rel="prefetch" href="/assets/js/73.ea6ade7f.js"><link rel="prefetch" href="/assets/js/74.550abe27.js"><link rel="prefetch" href="/assets/js/75.b6ba94c7.js"><link rel="prefetch" href="/assets/js/76.d9be8311.js"><link rel="prefetch" href="/assets/js/77.c741602e.js"><link rel="prefetch" href="/assets/js/78.7d7dccae.js"><link rel="prefetch" href="/assets/js/79.735ebdb9.js"><link rel="prefetch" href="/assets/js/8.4b2dcb4b.js"><link rel="prefetch" href="/assets/js/80.ab64326d.js"><link rel="prefetch" href="/assets/js/81.521d52d2.js"><link rel="prefetch" href="/assets/js/82.e58380f1.js"><link rel="prefetch" href="/assets/js/83.ff0a7bc1.js"><link rel="prefetch" href="/assets/js/84.057d563c.js"><link rel="prefetch" href="/assets/js/85.1baf7466.js"><link rel="prefetch" href="/assets/js/86.3b80b50f.js"><link rel="prefetch" href="/assets/js/87.1343fb2c.js"><link rel="prefetch" href="/assets/js/88.f116368b.js"><link rel="prefetch" href="/assets/js/89.dee0317f.js"><link rel="prefetch" href="/assets/js/9.e2efb1a3.js"><link rel="prefetch" href="/assets/js/90.55c09ff9.js"><link rel="prefetch" href="/assets/js/91.1be0adf4.js"><link rel="prefetch" href="/assets/js/92.41b7ba73.js"><link rel="prefetch" href="/assets/js/93.73d57323.js"><link rel="prefetch" href="/assets/js/94.937d97d7.js"><link rel="prefetch" href="/assets/js/95.09e5bb00.js"><link rel="prefetch" href="/assets/js/96.ad96fddc.js"><link rel="prefetch" href="/assets/js/97.e5f1fa64.js"><link rel="prefetch" href="/assets/js/98.4c24bcbe.js"><link rel="prefetch" href="/assets/js/99.bf29e7d8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.615f1c30.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>frenchleave</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>冯春齐 fengchunqi frenchleave blog</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>fengchunqi</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2025
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="frenchleave" class="logo"> <span class="site-name">frenchleave</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/About/" class="nav-link"><i class="undefined"></i>
  About
</a></li><li class="dropdown-item"><!----> <a href="/categories/Articles/" class="nav-link"><i class="undefined"></i>
  Articles
</a></li><li class="dropdown-item"><!----> <a href="/categories/Study/" class="nav-link"><i class="undefined"></i>
  Study
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="/pages/comments/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/about/author.html" class="nav-link"><i class="undefined"></i>
  关于作者
</a></li><li class="dropdown-item"><!----> <a href="/pages/about/website.html" class="nav-link"><i class="undefined"></i>
  关于本站
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    fengchunqi
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>118</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>19</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/About/" class="nav-link"><i class="undefined"></i>
  About
</a></li><li class="dropdown-item"><!----> <a href="/categories/Articles/" class="nav-link"><i class="undefined"></i>
  Articles
</a></li><li class="dropdown-item"><!----> <a href="/categories/Study/" class="nav-link"><i class="undefined"></i>
  Study
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="/pages/comments/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/about/author.html" class="nav-link"><i class="undefined"></i>
  关于作者
</a></li><li class="dropdown-item"><!----> <a href="/pages/about/website.html" class="nav-link"><i class="undefined"></i>
  关于本站
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/articles/interview/qian-duan-mian-shi-html.html" class="sidebar-link">前端面试-HTML</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-css.html" class="sidebar-link">前端面试-CSS</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-javascript.html" class="sidebar-link">前端面试-JavaScript</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-typescript.html" class="sidebar-link">前端面试-TypeScript</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html" aria-current="page" class="active sidebar-link">前端面试-Vue</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-promise.html" class="sidebar-link">前端面试-Promise</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-wang-luo-xiang-guan.html" class="sidebar-link">前端面试-网络相关</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html" class="sidebar-link">前端面试-XX与XX的区别</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-dai-ma-shu-chu.html" class="sidebar-link">前端面试-代码输出</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-zhu-guan-ti.html" class="sidebar-link">前端面试-主观题</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-gou-jian-gong-ju.html" class="sidebar-link">前端面试-构建工具</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-react.html" class="sidebar-link">前端面试-React</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NPM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VSCode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>前端面试-Vue</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>fengchunqi</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2025
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">前端面试-Vue</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>fengchunqi</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2021/5/10</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/pages/articles/interview/qian-duan-mian-shi-vue.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>Interview</span><span class="tag-item" data-v-1ff7123e>Vue</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="header-anchor">#</a> 说说你对vue的理解</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/dJ8WPIQ9xtI_SYfxGdUKeg" target="_blank" rel="nofollow noopener noreferrer">面试官：说说你对vue的理解?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Vue三要素</p> <ul><li><p>响应式：例如如何监听数据变化，其中的实现方法就是我们提到的双向绑定</p></li> <li><p>模板引擎：如何解析模板</p></li> <li><p>渲染：Vue如何将监听到的数据变化和解析后的HTML进行渲染</p></li> <li><p>数据驱动（<code>MVVM</code>）</p> <p><code>MVVM</code>表示的是 <code>Model-View-ViewModel</code></p> <ul><li><code>Model</code>：模型层，负责处理业务逻辑以及和服务器端进行交互</li> <li><code>View</code>：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li> <li><code>ViewModel</code>：视图模型层，用来连接 <code>Model</code> 和 <code>View</code> ，是 <code>Model</code> 和 <code>View</code> 之间的通信桥梁，Vue里的<code>data</code>部分就是<code>ViewModel</code></li></ul></li> <li><p>组件化</p></li> <li><p>指令系统，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM，<code>v-if</code>, <code>v-for</code>, <code>v-show</code>, <code>v-bind</code>, <code>v-on</code>, <code>v-model</code></p></li></ul> <h2 id="说说你对spa-单页应用-的理解"><a href="#说说你对spa-单页应用-的理解" class="header-anchor">#</a> 说说你对SPA（单页应用）的理解</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/HMMNqgVrkG7WPSq-ipR9WQ" target="_blank" rel="nofollow noopener noreferrer">面试官：说说你对SPA（单页应用）的理解?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <table><thead><tr><th>—</th> <th>单页面应用（SPA）</th> <th>多页面应用（MPA）</th></tr></thead> <tbody><tr><td>组成</td> <td>一个主页面和多个页面片段</td> <td>多个主页面</td></tr> <tr><td>刷新方式</td> <td>局部刷新</td> <td>整页刷新</td></tr> <tr><td>url模式</td> <td>哈希模式</td> <td>历史模式</td></tr> <tr><td>SEO搜索引擎优化</td> <td>难实现，可使用SSR方式改善</td> <td>容易实现</td></tr> <tr><td>数据传递</td> <td>容易</td> <td>通过url、cookie、localStorage等传递</td></tr> <tr><td>页面切换</td> <td>速度快，用户体验良好</td> <td>切换加载资源，速度慢，用户体验差</td></tr> <tr><td>维护成本</td> <td>相对容易</td> <td>相对复杂</td></tr></tbody></table> <p>单页应用优缺点</p> <p>优点：</p> <ul><li>具有桌面应用的即时性、网站的可移植性和可访问性</li> <li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li> <li>基于上面一点，SPA相对对服务器压力小</li> <li>良好的前后端分离，分工更明确，前端进行交互逻辑，后端负责数据处理</li></ul> <p>缺点：</p> <ul><li>不利于搜索引擎的抓取</li> <li>首次渲染速度相对较慢，初次加载耗时多：为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面按需加载</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理</li></ul> <p>Vue做SEO的三种方式：</p> <ol><li><p>SSR服务端渲染</p> <p>将组件或页面通过服务器生成html，再返回给浏览器，如 <code>nuxt.js</code></p></li> <li><p>静态化</p> <p>目前主流的静态化主要有两种：</p> <ul><li>一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中</li> <li>另外一种是通过WEB服务器的 <code>URL Rewrite</code> 的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果</li></ul></li> <li><p>使用 <code>Phantomjs</code> 针对爬虫处理</p> <p>原理是通过 <code>Nginx</code> 配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个 <code>node server</code> ，再通过 <code>PhantomJS</code> 来解析完整的HTML，返回给爬虫。</p></li></ol> <h2 id="说说你对双向绑定的理解"><a href="#说说你对双向绑定的理解" class="header-anchor">#</a> 说说你对双向绑定的理解</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/TV4mwb4JmjQjp304id-LZw" target="_blank" rel="nofollow noopener noreferrer">面试官：说说你对双向绑定的理解?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li><code>new Vue()</code>首先执行初始化，对data执行响应化处理，这个过程发生<code>Observer</code>中</li> <li>同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在<code>Compile</code>中</li> <li>同时定义一个更新函数和<code>Watcher</code>，将来对应数据变化时<code>Watcher</code>会调用更新函数</li> <li>由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家<code>Dep</code>来管理多个<code>Watcher</code></li> <li>将来data中数据一旦发生变化，会首先找到对应的<code>Dep</code>，通知所有<code>Watcher</code>执行更新函数</li></ol> <p>数据双向绑定的详细步骤：</p> <ol><li>实现一个监听器<code>Observer</code>：对数据对象进行遍历，包括子属性对象的属性，利用<code>Object.defineProperty()</code>对属性都加上<code>setter</code>和<code>getter</code>。这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化。</li> <li>实现一个解析器<code>Compile</code>：解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li> <li>实现一个订阅者<code>Watcher</code>：<code>Watcher</code>订阅者是<code>Observer</code>和<code>Compile</code>之间通信的桥梁，主要的任务是订阅<code>Observer</code>中的属性值变化的消息，当收到属性值变化的消息时，触发解析器<code>Compile</code>中对应的更新函数。</li> <li>实现一个订阅器<code>Dep</code>：订阅器采用发布-订阅设计模式，用来收集订阅者<code>Watcher</code>，对监听器<code>Observer</code>和订阅者<code>Watcher</code>进行统一管理。</li></ol> <div class="img-container" data-v-a458ecf0><div class="img-wrapper" style="width:;height:;max-width:100px;max-height:100px;" data-v-a458ecf0><img src="/image-default.png" alt="image-default" class="image-default" data-v-a458ecf0></img></div></div> <h2 id="说说你对vue生命周期的理解"><a href="#说说你对vue生命周期的理解" class="header-anchor">#</a> 说说你对Vue生命周期的理解</h2> <p>参考文章：<a href="/pages/articles/vue/对Vue生命周期的理解.html">对Vue生命周期的理解?</a></p> <h2 id="vue组件间通信方式都有哪些"><a href="#vue组件间通信方式都有哪些" class="header-anchor">#</a> Vue组件间通信方式都有哪些</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/uFjMz6BByA5eknBgkvgdeQ" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue组件间通信方式都有哪些?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>组件间通信的分类可以分成以下</p> <ul><li>父子组件之间的通信</li> <li>兄弟组件之间的通信</li> <li>祖孙与后代组件之间的通信</li> <li>非关系组件间之间的通信</li></ul> <p>Vue 中8种常规的通信方案</p> <ol><li>通过 <code>props</code> 传递</li> <li>通过 <code>$emit</code> 触发自定义事件</li> <li>使用 <code>ref</code> + <code>$refs</code></li> <li><code>EventBus</code>：一个无DOM的空组件，通过<code>$emit</code>和<code>$on</code>处理事件</li> <li><code>$parent</code> 或 <code>$root</code>，<code>$children</code></li> <li><code>$attrs</code> 与 <code>$listeners</code></li> <li><code>provide</code> 与 <code>inject</code></li> <li><code>Vuex</code></li></ol> <p>注意事项：</p> <ol><li>使用<code>vm.$parent</code>和<code>vm.$children</code>直接去修改父级或者子级的数据是可以的，但是会有一个问题，修改子级数据，但是子级的数组顺序是不能保证的，有可能造成操作失败。如果是使用<code>vm.$parent</code>去修改父级数据，那么只要这个组件引用的地方都会去修改父级，有的组件不需要修改但是被修改了，甚至有的修改会造成程序出错。</li></ol> <p><code>$root</code>，<code>$parent</code>，<code>$children</code>，<code>$refs</code>的使用：</p> <ul><li><p><code>vm.$root</code>：当前组件树的根Vue实例。如果当前实例没有父实例，此实例将会是其自己。一般就是<code>App.vue</code>组件。</p></li> <li><p><code>vm.$parent</code>：当前组件的父实例，如果当前实例有的话。</p></li> <li><p><code>vm.$children</code>：当前实例的直接子组件。需要注意<code>$children</code>并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用<code>$children</code>来进行数据绑定，考虑使用一个数组配合<code>v-for</code>来生成子组件，并且使用Array作为真正的来源。</p></li> <li><p><code>vm.$refs</code>：一个对象，持有注册过<code>ref</code> attribute 的所有DOM元素和组件实例。它不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板进行数据绑定或计算属性中访问<code>$refs</code>。</p> <ul><li>如果有多个相同的<code>ref</code>，如果这些相同的<code>ref</code>指向的组件或者DOM是嵌套的层级关系，<code>this.$refs[ref名称]</code>指向的是最外层那个。如果不是嵌套关系，指向的是文档流中位置靠下的那个。</li> <li>如果<code>ref</code>使用在<code>v-for</code>中，当循环内的<code>ref</code>值不同时，需提供<code>this.$refs[ref名称][0]</code>来获取该DOM节点或组件实例；当<code>ref</code>值相同时，<code>this.$refs[ref名称]</code>获取到的是该DOM节点或组件的数组。</li></ul></li></ul> <h2 id="为什么不用-root而要使用vuex呢"><a href="#为什么不用-root而要使用vuex呢" class="header-anchor">#</a> 为什么不用$root而要使用vuex呢</h2> <p>vue框架中组件可以通过<code>this.$root.data</code>的方式访问根组件的<code>data</code>对象，为何不直接把全局状态放在这里，反而使用vuex呢？</p> <ol><li>追踪变化，主要是方便开发调试</li> <li>避免污染，或随意修改(类似angularjs里面的$rootscope)</li> <li>vuex体现了代码分层的思想：<code>this.$root</code>更像是一个数据点，所有公共数据都流向了这个点，即与根组件耦合，又违背了接口隔离原则。而有了vuex这一层，我们就可以专注于这类数据的操作了，例如：可以针对不同的组件群创建不同的公共数据容器，这样明显合理多了</li> <li>vuex“通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护”，典型的如：要修改数据，必须通过提交<code>mutation</code>的方式，而不是随意改变这种多方依赖的公共数据</li> <li>稍微大型的项目会遇到问题，无法回溯，无法利用中间件记录变更日志、调试等，而数据回溯、监听中间件等功能是必须要有的。</li> <li>vuex背后反映的一些单向数据流，分层比如module，如果需要还是得去root里面去自己实现。</li></ol> <h2 id="vue中的v-show和v-if怎么理解"><a href="#vue中的v-show和v-if怎么理解" class="header-anchor">#</a> Vue中的v-show和v-if怎么理解</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/9CtghxcWPDZYIOiCjaYDcQ" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue中的v-show和v-if怎么理解？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p>控制手段：<code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p></li> <li><p>编译过程：<code>v-if</code>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于css切换</p></li> <li><p>编译条件：<code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p> <ul><li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li> <li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestroy</code>、<code>destroyed</code>方法</li></ul></li> <li><p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗</p></li></ul> <h2 id="为什么vue中的v-if和v-for不建议一起用"><a href="#为什么vue中的v-if和v-for不建议一起用" class="header-anchor">#</a> 为什么Vue中的v-if和v-for不建议一起用</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/xqgq7Ki5Yx0AEh1vIbiTqQ" target="_blank" rel="nofollow noopener noreferrer">面试官：为什么Vue中的v-if和v-for不建议一起用?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>v-for</code> 优先级比 <code>v-if</code> 高</p> <ul><li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li> <li>如果避免出现这种情况，则在外层嵌套 <code>template</code> （页面渲染不生成<code>dom</code>节点），在这一层进行<code>v-if</code>判断，然后在内部进行<code>v-for</code>循环</li> <li>如果条件出现在循环内部，可通过计算属性 <code>computed</code> 提前过滤掉那些不需要显示的项</li></ul> <h2 id="spa首屏加载速度慢的怎么解决"><a href="#spa首屏加载速度慢的怎么解决" class="header-anchor">#</a> SPA首屏加载速度慢的怎么解决</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/OMpQWfVkYHc_FCA2kIWhew" target="_blank" rel="nofollow noopener noreferrer">面试官：SPA（单页应用）首屏加载速度慢怎么解决？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>性能指标</p> <ul><li>FP（首次绘制）</li> <li>FCP（首次内容绘制 First contentful paint）</li> <li>LCP（最大内容绘制时间 Largest contentful paint）</li> <li>FPS（每秒传输帧数）</li> <li>TTI（页面可交互时间 Time to Interactive）</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 通过DOMContentLoad或者performance来计算出首屏时间</span>
<span class="token comment">// 方案一：</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first contentful painting'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 方案二：</span>
performance<span class="token punctuation">.</span><span class="token function">getEntriesByName</span><span class="token punctuation">(</span><span class="token string">'first-contentful-paint'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>startTime<span class="token punctuation">;</span>
<span class="token comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span>
<span class="token comment">// 会返回一个 PerformancePaintTiming 的实例，结构如下：</span>
<span class="token comment">// {</span>
<span class="token comment">//   name: &quot;first-contentful-paint&quot;,</span>
<span class="token comment">//   entryType: &quot;paint&quot;,</span>
<span class="token comment">//   startTime: 507.80000002123415,</span>
<span class="token comment">//   duration: 0,</span>
<span class="token comment">// };</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>加载慢的原因</p> <ul><li>网络延时问题</li> <li>资源文件体积是否过大</li> <li>资源是否重复发送请求去加载了</li> <li>加载脚本的时候，渲染内容堵塞了</li></ul> <p>常见的几种SPA首屏优化方式</p> <ul><li>减小入口文件积</li> <li>静态资源本地缓存</li> <li>UI框架按需加载</li> <li>图片资源的压缩</li> <li>组件重复打包</li> <li>开启GZip压缩</li> <li>使用SSR</li></ul> <div class="img-container" data-v-a458ecf0><div class="img-wrapper" style="width:;height:;max-width:100px;max-height:100px;" data-v-a458ecf0><img src="/image-default.png" alt="image-default" class="image-default" data-v-a458ecf0></img></div></div> <h2 id="vue中组件和插件有什么区别"><a href="#vue中组件和插件有什么区别" class="header-anchor">#</a> Vue中组件和插件有什么区别</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/Wi0r38LBopsyQ9HesMID0g" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue中组件和插件有什么区别？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>对组件的定义：</p> <p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在 Vue 中每一个 <code>.vue</code> 文件都可以视为一个组件</p> <p>组件的优势</p> <ul><li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li> <li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li> <li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li></ul> <p>插件是什么</p> <p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制，一般有下面几种：</p> <ul><li>添加全局方法或者属性。如: <code>vue-custom-element</code></li> <li>添加全局资源：指令/过滤器/过渡等。如 <code>vue-touch</code></li> <li>通过全局混入来添加一些组件选项。如 <code>vue-router</code></li> <li>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li> <li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <code>vue-router</code></li></ul> <h2 id="为什么data属性是一个函数而不是一个对象"><a href="#为什么data属性是一个函数而不是一个对象" class="header-anchor">#</a> 为什么data属性是一个函数而不是一个对象</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/vgyEZdBN_J24Q5j67aAVfQ" target="_blank" rel="nofollow noopener noreferrer">面试官：为什么data属性是一个函数而不是一个对象？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>根实例对象 <code>data</code> 可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li> <li>组件实例对象 <code>data</code> 必须为函数，目的是为了防止多个组件实例对象之间共用一个 <code>data</code> ，产生数据污染。采用函数的形式， <code>initData</code> 时会将其作为工厂函数都会返回全新 <code>data</code> 对象</li></ul> <h2 id="vue中给对象添加新属性界面不刷新"><a href="#vue中给对象添加新属性界面不刷新" class="header-anchor">#</a> Vue中给对象添加新属性界面不刷新</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/ygjeVKjNySWFFGzY0nQApQ" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue中给对象添加新属性界面不刷新?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Vue 不允许在已经创建的实例上动态添加新的响应式属性</p> <p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p> <ul><li><p>Vue.set(target, propertyName/index, value)</p> <p>别名：vm.$set()，参数一样</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li> <li><code>{any} value</code></li></ul></li> <li><p>Object.assign()</p> <p>直接使用 <code>Object.assign()</code> 添加到对象的新属性不会触发更新，应创建一个新的对象，合并原对象和混入对象的属性</p> <p><code>this.someObject = Object.assign({}, this.someObject, {newProperty1:1, newProperty2:2 ...})</code></p></li> <li><p>vm.$forcecUpdated()</p> <p>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p></li></ul> <p>P.S.： <code>vue3</code> 是用过 <code>proxy</code> 实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p> <h2 id="vue实例挂载的过程中发生了什么"><a href="#vue实例挂载的过程中发生了什么" class="header-anchor">#</a> Vue实例挂载的过程中发生了什么</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/8-PBIlLaQDJLu_SNU-mMLA" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue实例挂载的过程中发生了什么?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p><code>new Vue</code> 的时候调用会调用 <code>_init</code> 方法</p> <ul><li>定义 <code>$set</code> 、 <code>$get</code>  、 <code>$delete</code> 、 <code>$watch</code> 等方法</li> <li>定义 <code>$on</code> 、 <code>$off</code> 、 <code>$emit</code> 、 <code>$off</code> 等事件</li> <li>定义 <code>_update</code> 、 <code>$forceUpdate</code> 、 <code>$destroy</code> 生命周期</li> <li>事件监听（<code>initEvents(vm)</code>） -&gt; 渲染方法（<code>initRender(vm)</code>）-&gt; <code>initInjections(vm)</code> -&gt; <code>initState(vm) (props -&gt; methods -&gt; data -&gt; computed -&gt; watch)</code> -&gt; <code>initProvide(vm)</code>，这些处理完成才会触发 <code>created</code> 方法</li></ul></li> <li><p>调用 <code>$mount</code> 进行页面的挂载</p></li> <li><p>挂载的时候主要是通过 <code>mountComponent</code> 方法</p></li> <li><p>定义 <code>updateComponent</code> 更新函数</p></li> <li><p>执行 <code>render</code> 生成虚拟 <code>DOM</code></p></li> <li><p><code>_update</code> 将虚拟 <code>DOM</code> 生成真实 <code>DOM</code> 结构，并且渲染到页面中</p></li></ul> <h2 id="vue中的-nexttick有什么作用"><a href="#vue中的-nexttick有什么作用" class="header-anchor">#</a> Vue中的$nextTick有什么作用</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/GzuKsrdBjPv7fgSJry2K0A" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue中的$nextTick怎么理解?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>nextTick</code> 是什么</p> <blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p></blockquote> <ul><li><code>Vue.nextTick( [callback, context] )</code></li> <li><code>vm.$nextTick( [callback] )</code></li></ul> <p><code>vm.$nextTick()</code> 跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p> <p>Vue 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化， Vue 将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</p> <blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 <code>Promise</code> 的环境中，则返回一个 <code>Promise</code></p></blockquote> <p>原理</p> <ul><li>把回调函数放入 <code>callbacks</code> (异步操作队列)等待执行</li> <li>将执行函数放到微任务或者宏任务中( <code>Promise.then</code> 、 <code>MutationObserver</code> 、 <code>setImmediate</code> 、 <code>setTimeout</code> )</li> <li>事件循环到了微任务或者宏任务，执行函数依次执行 <code>callbacks</code> 中的回调</li></ul> <h2 id="说说你对vue的mixin的理解"><a href="#说说你对vue的mixin的理解" class="header-anchor">#</a> 说说你对vue的mixin的理解</h2> <p>参考文章：<a href="/pages/articles/vue/Vue的mixin的理解.html">Vue的mixin的理解</a></p> <p><code>mixin</code>（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p> <p>本质其实就是一个 <code>js</code> 对象，它可以包含我们组件中任意功能选项，如 <code>data</code> 、 <code>components</code> 、 <code>methods</code> 、 <code>created</code> 、 <code>computed</code> 等等</p> <p>我们只要将共用的功能以对象的方式传入 <code>mixins</code> 选项中，当组件使用 <code>mixins</code> 对象时所有 <code>mixins</code> 对象的选项都将被混入该组件本身的选项中来</p> <p>在 Vue 中我们可以局部混入跟全局混入</p> <p>使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）</p> <p>当组件存在与 <code>mixin</code> 对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖 <code>mixin</code> 的选项</p> <p>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行 <code>mixin</code> 的钩子，再执行组件的钩子</p> <h2 id="说说你对slot的理解slot使用场景有哪些"><a href="#说说你对slot的理解slot使用场景有哪些" class="header-anchor">#</a> 说说你对slot的理解slot使用场景有哪些</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/GMX_AzCeCYJUVO2DGdUKrA" target="_blank" rel="nofollow noopener noreferrer">面试官：说说你对slot的理解？slot使用场景有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>slot可以分来以下三种：</p> <ul><li><p>默认插槽</p></li> <li><p>具名插槽</p></li> <li><p>作用域插槽</p></li> <li><p><code>v-slot</code> 属性只能在 <code>&lt;template&gt;</code> 上使用，但在只有默认插槽时可以在组件标签上使用</p></li> <li><p>默认插槽名为 <code>default</code> ，可以省略 <code>default</code> 直接写 <code>v-slot</code></p></li> <li><p>缩写为 <code>#</code> 时不能不写参数，写成 <code>#default</code></p></li> <li><p>可以通过解构获取 <code>v-slot={user}</code> ，还可以重命名 <code>v-slot=&quot;{user: newName}&quot;</code> 和定义默认值 <code>v-slot=&quot;{user = '默认值'}&quot;</code></p></li></ul> <h2 id="vue-observable你有了解过吗说说看"><a href="#vue-observable你有了解过吗说说看" class="header-anchor">#</a> Vue.observable你有了解过吗说说看</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/3awkQmdecorBdX1OaQHoag" target="_blank" rel="nofollow noopener noreferrer">面试官：说说对observable的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>Observable</code> 翻译过来我们可以理解成可观察的</p> <blockquote><p><code>Vue.observable</code>，让一个对象变成响应式数据。Vue 内部会用它来处理 <code>data</code> 函数返回的对象</p></blockquote> <p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器</p> <p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象</p> <p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token comment">// 创建state对象，使用observable让state对象可响应</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> state <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">38</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建对应的方法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">changeName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><div class="language-Vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    姓名：{{ name }}
    年龄：{{ age }}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>changeName(<span class="token punctuation">'</span>李四<span class="token punctuation">'</span>)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      改变姓名
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>setAge(18)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      改变年龄
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> mutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在计算属性中拿到值</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 调用mutations里面的方法，更新数据</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    changeName<span class="token operator">:</span> mutations<span class="token punctuation">.</span>changeName<span class="token punctuation">,</span>
    setAge<span class="token operator">:</span> mutations<span class="token punctuation">.</span>setAge<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="你知道vue中key的原理吗"><a href="#你知道vue中key的原理吗" class="header-anchor">#</a> 你知道vue中key的原理吗</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/8mRnWdBGJ7vg6q6PfJdK2Q" target="_blank" rel="nofollow noopener noreferrer">面试官：说说为什么要在列表组件中写 key，其作用是什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>两个实际工作场景</p> <ol><li><p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p> <div class="language-HTML line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in items<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</p> <div class="language-HTML line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>+new Date()<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <blockquote><p><code>key</code>是给每一个<code>vnode</code>的唯一<code>id</code>，也是<code>diff</code>的一种优化策略，可以根据<code>key</code>，更准确，更快的找到对应的<code>vnode</code>节点</p></blockquote> <p>源码地址：vue/src/core/vdom/patch.js</p> <p>Vue中<code>key</code>的作用是：<code>key</code>是为Vue中<code>vnode</code>的唯一标记，通过这个<code>key</code>，我们的<code>diff</code>操作可以更准确、更快速。</p> <ul><li>更准确：因为带<code>key</code>就不是就地复用了，在sameNode函数<code>a.key === b.key</code>对比中可以避免就地复用的情况。所以会更加准确。</li> <li>更快速：利用<code>key</code>的唯一性生成map对象来获取对应节点，比遍历方式更快。</li></ul> <p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p> <ul><li>如果不用<code>key</code>，Vue会采用就地复地原则：最小化<code>element</code>的移动，并且会尝试尽最大程度在同适当的地方对相同类型的<code>element</code>，做<code>patch</code>或者<code>reuse</code>。</li> <li>如果使用了<code>key</code>，Vue会根据<code>keys</code>的顺序记录<code>element</code>，曾经拥有了<code>key</code>的<code>element</code>如果不再出现的话，会被直接<code>remove</code>或者<code>destoryed</code>。</li></ul> <p>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</p> <ul><li>当拥有新值的<code>rerender</code>作为<code>key</code>时，拥有了新<code>key</code>的<code>Comp</code>出现了，那么旧<code>key</code>的<code>Comp</code>会被移除，新<code>key</code>的<code>Comp</code>触发渲染。</li></ul> <p>设置<code>key</code>值不一定能提高<code>diff</code>效率：</p> <blockquote><p>当<code>Vue.js</code>用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不会移动<code>DOM</code>元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素</p></blockquote> <p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时<code>DOM</code>状态（例如：表单输入值）的列表渲染输出。建议尽可能在使用<code>v-for</code>时提供<code>key</code>，除非遍历输出的<code>DOM</code>内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p> <h2 id="说说你对keep-alive的理解"><a href="#说说你对keep-alive的理解" class="header-anchor">#</a> 说说你对keep-alive的理解</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/LGKVWXxm4ICI4FTbIK5dOQ" target="_blank" rel="nofollow noopener noreferrer">面试官：说说你对keep-alive的理解是什么？怎么缓存当前的组件？缓存后怎么更新？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p><code>keep-alive</code> 是 Vue 中的内置组件，能在组件切换过程中将状态保留在内存中，使其不被销毁，防止重复渲染 <code>DOM</code></p></li> <li><p><code>keep-alive</code> 其拥有两个独立的生命周期钩子函数<code>actived</code>和<code>deactived</code>，使用<code>keep-alive</code>包裹的组件在切换时不会被销毁，而是缓存到内存中并执行<code>deactived</code>钩子函数，命中缓存渲染后会执行<code>actived</code>钩子函数。</p></li> <li><p><code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 <code>DOM</code> 元素，也不会出现在组件的父组件链中。</p></li> <li><p><code>keep-alive</code> 可以设置以下 <code>props</code> 属性：</p> <ul><li><code>include</code> - 字符串或正则表达式或数组。只有名称匹配的组件会被缓存</li> <li><code>exclude</code> - 字符串或正则表达式或数组。任何名称匹配的组件都不会被缓存</li> <li><code>max</code> - 字符串或数字。最多可以缓存多少组件实例</li></ul></li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>view<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a,b<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>view<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/a|b/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>view<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>[<span class="token punctuation">'</span>a<span class="token punctuation">'</span>, <span class="token punctuation">'</span>b<span class="token punctuation">'</span>]<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>view<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>wrapper<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 需要缓存的视图组件 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$route.meta.keepAlive<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 不需要缓存的视图组件 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>!$route.meta.keepAlive<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配。所以 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部/全局注册（但是在源码中如果没有提供<code>name</code>，它会去匹配<code>tag</code>）。</p> <p>设置了 <code>keep-alive</code> 缓存的组件，会多出两个生命周期钩子（ <code>activated</code> 与 <code>deactivated</code> ）：</p> <ul><li>首次进入组件时： <code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li> <li>再次进入组件时： <code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></li></ul> <ol><li><p>缓存后如何获取数据</p> <p>每次组件渲染的时候，都会执行 <code>beforeRouteEnter</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
      <span class="token comment">// 每次进入路由执行</span>
      vm<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 获取数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 <code>keep-alive</code> 缓存的组件被激活的时候，都会执行 <code>actived</code> 钩子</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取数据</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意：服务器端渲染期间 <code>avtived</code> 不被调用</p></li> <li><p>为什么不会生成真正的DOM节点？</p> <p>Vue在初始化生命周期的时候，为组件实例建立父子关系会根据<code>abstract</code>属性决定是否忽略某个组件。在<code>keep-alive</code>中，设置了<code>abstract:true</code>，那Vue就会跳过该组件实例。最后构建的组件树中就不会包含<code>keep-alive</code>组件，那么由组件树渲染成的DOM树自然也不会有<code>keep-alive</code>相关的节点了。</p></li> <li><p>keep-alive包裹的组件是如何使用缓存的？</p> <ul><li><p>源码：<code>vue/src/core/components/keep-alive.js</code></p></li> <li><p>参考：<a href="https://www.cnblogs.com/wangjiachen666/p/11497200.html" target="_blank" rel="nofollow noopener noreferrer">通俗易懂了解Vue内置组件keep-alive内部原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>在首次加载被包裹组建时，由keep-alive.js中的<code>render</code>函数可知，首先获取组件名字，如果设置的缓存规则无法匹配当前组件，直接返回这个组件。</p></li> <li><p>如果能匹配上，获取当前的缓存和缓存的<code>keys</code>，如果当前组件的<code>key</code>不存在则生成一个，判断这个<code>key</code>在缓存<code>cache</code>中是否有值，如果有就直接取缓存，并且根据LRU算法把节点的<code>key</code>移动到最后，如果没有缓存，则把当前节点添加到缓存中，以备下次使用，如果新加入缓存组件之后，缓存组件的数量大于了设定的最大值，那么就需要删除第一个缓存。</p></li> <li><p>再次访问被包裹组件时，<code>cache</code>中已经有组件的<code>key</code>对应的缓存了，直接取用，并更新缓存的顺序。</p></li></ul> <blockquote><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p></blockquote></li></ol> <h2 id="vue常用的修饰符"><a href="#vue常用的修饰符" class="header-anchor">#</a> Vue常用的修饰符</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/yYyg0KExeQTnzecruB-9-Q" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue常用的修饰符有哪些?有什么应用场景?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>vue中修饰符分为以下五种：</p> <ul><li>表单修饰符</li> <li>事件修饰符</li> <li>鼠标按键修饰符</li> <li>键值修饰符</li> <li><code>v-bind</code> 修饰符</li></ul> <p><code>v-model</code> 指令的表单修饰符</p> <ul><li><code>lazy</code> : 在我们填完信息，光标离开标签的时候，才会将值赋予给 <code>value</code> ，也就是在 <code>change</code> 事件之后再进行信息同步</li> <li><code>trim</code> : 自动过滤用户输入的首尾空格字符，而中间的空格不会过滤</li> <li><code>number</code> : 自动将用户的输入值转为数值类型，但如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原来的值</li></ul> <p><code>v-on</code> 指令(<code>@</code>)的事件修饰符</p> <ul><li><code>stop</code>: 阻止了事件冒泡，相当于调用了 <code>event.stopPropagation</code> 方法</li> <li><code>prevent</code>: 阻止了事件的默认行为，相当于调用了 <code>event.preventDefault</code> 方法</li> <li><code>capture</code>: 添加事件监听器时使用事件捕获模式，即内部元素触发的事件先在此处理，然后才交由内部元素进行处理，使事件触发从包含这个元素的顶层开始往下触发</li> <li><code>self</code>: 只当在 <code>event.target</code> 是当前元素自身时触发处理函数，即事件不是从内部元素触发的</li> <li><code>once</code>: 点击事件将只会触发一次</li> <li><code>passive</code>: 在移动端，当我们在监听元素滚动事件的时候，会一直触发 <code>onscroll</code> 事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 <code>onscroll</code> 事件整了一个 <code>.lazy</code> 修饰符</li> <li><code>native</code>: 让组件变成像 <code>html</code> 内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件，使用 <code>.native</code> 修饰符来操作普通 <code>HTML</code> 标签是会令事件失效的</li> <li><code>.exact</code> : 修饰符允许你控制由精确的系统修饰符组合触发的事件。</li></ul> <p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p> <p>鼠标按钮修饰符</p> <ul><li><code>left</code> : 左键点击 <code>@click.left=&quot;shout(1)&quot;</code></li> <li><code>right</code> : 右键点击 <code>@click.right=&quot;shout(1)&quot;</code></li> <li><code>middle</code> : 中键点击 <code>@click.middle=&quot;shout(1)&quot;</code></li></ul> <p>键盘修饰符</p> <p>键盘修饰符是用来修饰键盘事件（ <code>onkeyup</code> ， <code>onkeydown</code> ）的，有如下：</p> <p><code>keyCode</code> 存在很多，但 Vue 为我们提供了别名，分为以下两种：</p> <p>普通键（ <code>enter</code> 、 <code>tab</code> 、 <code>delete</code> 、 <code>space</code> 、 <code>esc</code> 、 <code>up</code> 、 <code>down</code> 、 <code>left</code> 、 <code>right</code> ...）
系统修饰键（ <code>ctrl</code> 、 <code>alt</code> 、 <code>meta</code> 、 <code>shift</code> ...）</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@keyup.enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>shout()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>自定义按键修饰符别名： <code>Vue.config.keyCodes.f2 = 113</code></p> <p>v-bind修饰符</p> <ul><li><code>async</code> : 能对 <code>props</code> 进行一个双向绑定 <code>this.$emit('update:xxx', params);</code></li> <li><code>prop</code> : 作为一个 <code>DOM property</code> 绑定而不是作为 <code>attribute</code> 绑定</li> <li><code>camel</code> : 将 <code>kebab-case attribute</code> 名转换为 <code>camelCase</code></li></ul> <h2 id="vue自定义指令"><a href="#vue自定义指令" class="header-anchor">#</a> Vue自定义指令</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/Nq0l10W3EqT-N6Bzuy1iBQ" target="_blank" rel="nofollow noopener noreferrer">面试官：你有写过自定义指令吗？自定义指令的应用场景有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>全局注册注册主要是用过 <code>Vue.directive</code> 方法进行注册</p> <p><code>Vue.directive</code> 第一个参数是指令的名字（不需要写上 <code>v-</code> 前缀），第二个参数可以是对象数据，也可以是一个指令函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 注册一个全局自定义指令 v-focus</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当被绑定的元素插入到 DOM 中时……</span>
  <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 聚焦元素</span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>局部注册通过在组件 <code>options</code> 选项中设置 <code>directive</code> 属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>directives<span class="token operator">:</span> <span class="token punctuation">{</span>
  focus<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 指令的定义</span>
    <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>自定义指令也像组件那样存在钩子函数：</p> <ul><li><code>bind</code> ：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li> <li><code>inserted</code> ：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li> <li><code>update</code> ：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li> <li><code>componentUpdated</code> ：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用</li> <li><code>unbind</code> ：只调用一次，指令与元素解绑时调用</li></ul> <p>所有的钩子函数的参数都有以下：</p> <ul><li><p><code>el</code> ：指令所绑定的元素，可以用来直接操作 <code>DOM</code></p></li> <li><p><code>binding</code> ：一个对象，包含以下 <code>property</code> ：</p> <ul><li><code>name</code> ：指令名，不包括 <code>v-</code> 前缀。</li> <li><code>value</code> ：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code></li> <li><code>oldValue</code> ：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用</li> <li><code>expression</code> ：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code></li> <li><code>arg</code> ：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code></li> <li><code>modifiers</code> ：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code></li></ul></li> <li><p><code>vnode</code> ： Vue 编译生成的虚拟节点</p></li> <li><p><code>oldVnode</code> ：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</p></li></ul> <p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <code>dataset</code> 来进行</p> <h2 id="vue中的过滤器"><a href="#vue中的过滤器" class="header-anchor">#</a> Vue中的过滤器</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/IocloJ32RY6VzJFSeQzuFQ" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue中的过滤器了解吗？过滤器的应用场景有哪些？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Vue 中的过滤器可以用在两个地方：双花括号插值和 <code>v-bind</code> 表达式，过滤器应该被添加在 <code>JavaScript</code> 表达式的尾部，由“管道”符号指示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 在双花括号中 --&gt;</span>
<span class="token comment">&lt;!-- {{ message | capitalize }} --&gt;</span>
<span class="token comment">&lt;!-- 在 `v-bind` 中 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>rawId | formatId<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 在组件的选项中定义本地的过滤器</span>
filters<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">capitalize</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span>
    value <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义全局过滤器：</span>
Vue<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token string">'capitalize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span>
  value <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>注意：当全局过滤器和局部过滤器重名时，会采用<strong>局部过滤器</strong></p> <p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。</p> <h2 id="如何实现一个虚拟dom"><a href="#如何实现一个虚拟dom" class="header-anchor">#</a> 如何实现一个虚拟DOM</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/lAscEOQWkk-IQq6lWCdSSw" target="_blank" rel="nofollow noopener noreferrer">面试官：什么是虚拟DOM？如何实现一个虚拟DOM？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>虚拟DOM的实现原理主要包括以下3部分：</p> <ol><li>用JavaScript对象模拟真实DOM树，对真实DOM进行抽象，<code>{ tag: 'div', props: { class: 'item' }, children: [] }</code></li> <li>diff算法 — 比较两棵虚拟DOM树的差异；</li> <li>patch算法 — 将两个虚拟DOM对象的差异应用到真正的DOM树。</li></ol> <p>虚拟DOM的优缺点：</p> <p>优点</p> <ul><li>保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li>无需手动操作DOM：我们不再需要手动去操作DOM，只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li>跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器渲染、weex开发等等。</li></ul> <p>缺点</p> <ul><li>无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。</li> <li>需要额外的创建函数，如createElement或h，但可以通过JSX或者vue-loader来简化成XML写法。但是这么做会依赖打包工具。</li></ul> <h2 id="vue项目中有封装过axios吗"><a href="#vue项目中有封装过axios吗" class="header-anchor">#</a> Vue项目中有封装过axios吗</h2> <p>参考文章：<a href="/pages/articles/javascript/前端数据请求(axios,jQuery,原生).html">前端数据请求(axios, jQuery, 原生)</a></p> <ul><li><p>请求拦截</p> <ul><li>添加请求头，如token</li> <li>拼接公共请求地址</li> <li>请求数据格式Content-Type</li> <li>处理IE请求缓存</li> <li>timeout</li></ul></li> <li><p>响应拦截</p> <ul><li>状态码拦截</li> <li>权限及登录状态校验</li> <li>请求失败响应公共处理</li></ul></li></ul> <h2 id="有看过axios的源码吗"><a href="#有看过axios的源码吗" class="header-anchor">#</a> 有看过axios的源码吗</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/I8mJH4Dq7l7WRrwnb-q6tQ" target="_blank" rel="nofollow noopener noreferrer">面试官：你了解Axios的原理吗？有看过它的源码吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="ssr解决了什么问题有做过ssr吗"><a href="#ssr解决了什么问题有做过ssr吗" class="header-anchor">#</a> SSR解决了什么问题有做过SSR吗</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/vvUtC_aAprUjoJRnfFjA1A" target="_blank" rel="nofollow noopener noreferrer">面试官：SSR解决了什么问题？有做过SSR吗？你是怎么做的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>Server-Side Rendering</code> 我们称其为 <code>SSR</code> ，意为服务端渲染</p> <p>Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA</p> <p>SSR主要解决了以下两种问题：</p> <ul><li>seo：搜索引擎优先爬取页面HTML结构，使用SSR时，服务端已经生成了和业务想关联的HTML，有利于seo</li> <li>首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）</li></ul> <p>但是使用SSR同样存在以下的缺点：</p> <ul><li><p>复杂度：整个项目的复杂度</p></li> <li><p>库的支持性，代码兼容，服务端渲染只支持<code>beforCreate</code>和<code>created</code>两个钩子函数</p></li> <li><p>性能问题</p> <ul><li>每个请求都是n个实例的创建，不然会污染，消耗会变得很大</li> <li>缓存 node serve、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。</li> <li>降级：监控cpu、内存占用过多，就spa，返回单个的壳</li></ul></li> <li><p>服务器负载变大，相对于前后端分离务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用</p></li></ul> <p>所以在我们选择是否使用SSR前，我们需要慎重问问自己这些问题：</p> <ul><li>需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现</li> <li>首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢</li></ul> <p>小结</p> <ul><li>使用SSR不存在单例模式，每次用户请求都会创建一个新的vue实例</li> <li>实现SSR需要实现服务端首屏渲染和客户端激活</li> <li>服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取</li> <li>首屏异步获取数据，在服务端预渲染的时候就应该已经完成</li> <li>切换组件通过mixin混入，在beforeMount钩子完成数据获取</li></ul> <h2 id="vue开发过程你是怎么做接口管理的"><a href="#vue开发过程你是怎么做接口管理的" class="header-anchor">#</a> vue开发过程你是怎么做接口管理的</h2> <ul><li>Axios请求封装</li> <li>公用请求以及各个模块请求拆分</li></ul> <h2 id="说下你的vue项目的目录结构"><a href="#说下你的vue项目的目录结构" class="header-anchor">#</a> 说下你的vue项目的目录结构</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/ERsE32CXnF2fK8SKPWIneQ" target="_blank" rel="nofollow noopener noreferrer">面试官：说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在划分项目结构的时候，需要遵循一些基本的原则：</p> <ul><li>文件夹和文件夹内部文件的语义一致性</li> <li>单一入口/出口</li> <li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li> <li>公共的文件应该以绝对路径的方式从根目录引用</li> <li><code>/src</code> 外的文件不应该被引入</li></ul> <h2 id="vue要做权限管理该怎么做"><a href="#vue要做权限管理该怎么做" class="header-anchor">#</a> vue要做权限管理该怎么做</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/7d4maMFy_L2ho23DD_tdTw" target="_blank" rel="nofollow noopener noreferrer">面试官：Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p>路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页</p></li> <li><p>视图方面，用户只能看到自己有权浏览的内容和有权操作的控件</p></li> <li><p>最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截</p></li> <li><p>接口权限</p> <p>接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录</p></li> <li><p>路由权限</p> <p>方案一：初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p> <p>这种方式存在以下四种缺点：</p> <ul><li>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</li> <li>全局路由守卫里，每次路由跳转都要做权限判断。</li> <li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li> <li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul> <p>方案二：初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制，登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由</p> <p>这种方式也存在了以下的缺点：</p> <ul><li>全局路由守卫里，每次路由跳转都要做判断</li> <li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li> <li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul></li> <li><p>菜单权限</p> <p>菜单权限可以理解成将页面与理由进行解耦</p></li> <li><p>按钮权限</p> <p>按钮权限也可以用v-if判断或者通过自定义指令进行按钮权限的判断</p></li></ul> <h2 id="vue项目部署后报404是什么"><a href="#vue项目部署后报404是什么" class="header-anchor">#</a> vue项目部署后报404是什么</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/i9XSiIMn-jc3KQwZntHTug" target="_blank" rel="nofollow noopener noreferrer">面试官：vue项目如何部署？有遇到布署服务器后刷新404问题吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>history模式下有问题，因为切换路由会重载页面</p> <p>hash模式下没有问题，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面</p> <p>产生问题的本质是因为我们的路由是通过JS来执行视图切换的，当我们进入到子路由时刷新页面，web容器没有相对应的页面此时会出现404，所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理，对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p> <h2 id="你是怎么处理vue项目中的错误的"><a href="#你是怎么处理vue项目中的错误的" class="header-anchor">#</a> 你是怎么处理vue项目中的错误的</h2> <p>参考文章：<a href="https://mp.weixin.qq.com/s/OUKzCcMHUJH5CVtOJ1XKyA" target="_blank" rel="nofollow noopener noreferrer">面试官：你是怎么处理vue项目中的错误的？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>主要的错误来源包括：</p> <ul><li><p>后端接口错误</p> <p>通过axios的interceptor实现网络请求的response先进行一层拦截</p></li> <li><p>代码中本身逻辑错误</p> <p>设置全局错误处理函数，<code>errorHandler</code>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span>
  <span class="token comment">// 只在 2.2.0+ 可用</span>

  <span class="token comment">// 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。</span>
  <span class="token comment">// 同样的，当这个钩子是 undefined 时，被捕获的错误会通过</span>
  <span class="token comment">// console.error 输出而避免应用崩</span>

  <span class="token comment">// 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了</span>

  <span class="token comment">// 从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。</span>
  <span class="token comment">// 另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，</span>
  <span class="token comment">// 则来自其 Promise 链的错误也会被处理</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>生命周期钩子，<code>errorCaptured</code>是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token parameter">err<span class="token operator">:</span> Error<span class="token punctuation">,</span> vm<span class="token operator">:</span> Component<span class="token punctuation">,</span> info<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">?</span>boolean
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播</p></li></ul> <p>tips：使用其他插件如 <code>sentry</code></p> <h2 id="vue3跟vue2的区别吗"><a href="#vue3跟vue2的区别吗" class="header-anchor">#</a> Vue3跟Vue2的区别吗</h2> <p>参考文章：<a href="/pages/articles/vue/Vue3与Vue2的区别.html">Vue3与Vue2的区别</a></p> <h2 id="object-defineproperty和proxy比较"><a href="#object-defineproperty和proxy比较" class="header-anchor">#</a> Object.defineProperty和Proxy比较</h2> <p>链接：<a href="/pages/articles/javascript/Object.defineProperty和Proxy比较.html">Object.defineProperty和Proxy比较</a></p> <h2 id="vue项目中的性能方面优化"><a href="#vue项目中的性能方面优化" class="header-anchor">#</a> vue项目中的性能方面优化</h2> <ul><li><p>代码层面</p> <ul><li><code>v-if</code>和<code>v-show</code>选择调用</li> <li><code>computed</code>和<code>watch</code>区分使用场景</li> <li><code>v-for</code>为item设置唯一<code>key</code>值</li> <li>细分vuejs组件</li> <li>内容类系统的图片资源按需加载</li> <li>图片资源懒加载</li> <li>事件用完销毁</li> <li>第三方插件的按需引入</li> <li>优化无限列表性能</li> <li>对路由组件进行懒加载</li> <li>SSR(服务端渲染)</li> <li>公共组件、css、js方法的复用</li> <li>vue组件<code>keep-alive</code></li></ul></li> <li><p>webpack层面</p> <ul><li><code>webpack</code>对图片进行压缩</li> <li>减少<code>ES6</code>转为<code>ES5</code>的冗余代码，<code>Babel</code>插件会在将<code>ES6</code>代码转换成<code>ES5</code>代码时会注入一些辅助函数，<code>babel-plugin-transform-runtime</code>可以解决</li> <li>本地打包的gzip：<code>productionGzip: false</code></li> <li>添加<code>externals</code>来告诉<code>webpack</code>我们这些第三方库不需要打包</li></ul></li> <li><p>其他</p> <ul><li>nginx上开启gzip压缩</li> <li>服务器缓存，资源请求时匹配文件后缀获取文件类型，指定缓存时间(如<code>expires 1h;</code>)，<code>css</code>和<code>js</code>这些可以缓存时间长点甚至永久缓存，文件带有hash值，html文件则不要缓存太长时间</li> <li>浏览器缓存，<code>http-equiv</code>，语法格式是：<code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;</code>，例如：<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2007 22:33:00 GMT&quot;&gt;</code>，或者设置其他关于缓存的请求头字段，<code>Cache-Control</code>,<code>Expires</code>,<code>Last-Modified/If-Modified-Since</code>,<code>If-None-Match/Etags</code></li> <li>CDN</li> <li>预加载，<code>prefetch</code>，域名预解析 <code>&lt;link rel='dns-prefetch' href='http://www.baidu.com'&gt;</code></li></ul></li></ul> <h2 id="自定义组件的双向绑定怎么写"><a href="#自定义组件的双向绑定怎么写" class="header-anchor">#</a> 自定义组件的双向绑定怎么写</h2> <p><code>v-model</code>默认接收一个名为<code>value</code>的<code>props</code>值，触发事件为<code>input</code>，自定义组件中的触发<code>this.$emit('input', value)</code></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inputValue<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 等同于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inputValue<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inputValue = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以通过<code>mode</code>字段自定义<code>v-model</code>传递的数据名和触发的方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">&quot;currentValue&quot;</span><span class="token punctuation">,</span>
    event<span class="token operator">:</span> <span class="token string">&quot;change&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li><a href="/pages/articles/vue/Element自定义下拉框搜索.html">Element自定义下拉框搜索</a></li> <li><a href="/pages/articles/vue/Vue图片上传及预览.html">Vue图片上传及预览</a></li></ul> <h2 id="vue双向绑定的sync"><a href="#vue双向绑定的sync" class="header-anchor">#</a> vue双向绑定的sync</h2> <p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="nofollow noopener noreferrer">.sync 修饰符<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text-document</span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span><span class="token namespace">update:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title = $event<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text-document</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>简写成 <code>.sync</code> 修饰符</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text-document</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc.title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text-document</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>.sync</code>修饰符就是一个语法糖：<code>v-bind:title.sync=&quot;doc.title&quot;</code> === <code>@update:title=&quot;val =&gt; doc.title = val&quot;</code></p> <p>触发</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:title'</span><span class="token punctuation">,</span> newTitle<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=&quot;doc.title + '!'&quot;</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 <code>property</code> 名，类似 <code>v-model</code>。</p> <p>当我们用一个对象同时设置多个 <code>prop</code> 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text-document</span> <span class="token attr-name">v-bind.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doc<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>text-document</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p> <p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=&quot;{ title: doc.title }&quot;</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p> <h2 id="数组有哪些api会改变原数组"><a href="#数组有哪些api会改变原数组" class="header-anchor">#</a> 数组有哪些API会改变原数组</h2> <ul><li>copyWithin</li> <li>fill</li> <li>push</li> <li>pop</li> <li>unshift</li> <li>shift</li> <li>reverse</li> <li>sort</li> <li>splice</li></ul> <h2 id="mvvm和mvc区别"><a href="#mvvm和mvc区别" class="header-anchor">#</a> MVVM和MVC区别</h2> <ul><li><p>MVC</p> <p>MVC全名是Model View Controller，是模型（model）－视图（view）－控制器（controller）的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p> <p>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View。</p></li> <li><p>MVVM</p> <p>Model、View、ViewModel（ViewModel只是使得Controller弱化了，并非使它消亡）</p> <p>ViewModel：是 MVVM 的核心，是连接 View 与 Model 的桥梁。通过数据双向绑定实现。</p> <ul><li>方向1：通过<strong>数据绑定</strong>将模型转化成视图</li> <li>方向2：通过DOM<strong>事件监听</strong>，将视图转换为模型（即需要传给后端的数据）</li></ul></li></ul> <p>它和其它框架（如 jQuery）的区别是什么？</p> <ul><li>vue：通过对数据的操作就可以完成对页面视图的渲染</li> <li>jquery：直接操作DOM，对其进行赋值、取值、事件绑定等 操作</li></ul> <p>适合哪些场景？</p> <ul><li>vue：复杂数据操作的后台页面，表单填写页面；数据操作比较多的场景，更加便捷</li> <li>jquery：一些html5的动画页面，一些需要js来操作页面样式的页面。</li></ul> <h2 id="vue的父组件和子组件生命周期钩子函数执行顺序"><a href="#vue的父组件和子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> Vue的父组件和子组件生命周期钩子函数执行顺序</h2> <p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> <ul><li><p>加载渲染过程</p> <p>父 <code>beforeCreate</code> -&gt; 父 <code>created</code> -&gt; 父 <code>beforeMount</code> -&gt; 子 <code>beforeCreate</code> -&gt; 子 <code>created</code> -&gt; 子 <code>beforeMount</code> -&gt; 子 <code>mounted</code> -&gt; 父 <code>mounted</code></p> <p>注意：<code>mounted</code> 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <code>vm.$nextTick</code></p></li> <li><p>子组件更新过程</p> <p>父 <code>beforeUpdate</code> -&gt; 子 <code>beforeUpdate</code> -&gt; 子 <code>updated</code> -&gt; 父 <code>updated</code></p></li> <li><p>父组件更新过程</p> <p>父 <code>beforeUpdate</code> -&gt; 父 <code>updated</code></p></li> <li><p>销毁过程</p> <p>父 <code>beforeDestroy</code> -&gt; 子 <code>beforeDestroy</code> -&gt; 子 <code>destroyed</code> -&gt; 父 <code>destroyed</code></p></li></ul> <h2 id="vuerouter有哪些钩子函数"><a href="#vuerouter有哪些钩子函数" class="header-anchor">#</a> VueRouter有哪些钩子函数</h2> <ul><li><p>全局前置守卫<code>router.beforeEach</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>全局解析守卫<code>router.beforeResolve</code></p> <p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是<strong>在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</p></li> <li><p>全局后置钩子<code>router.afterEach</code></p> <p>和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>路由独享的守卫<code>beforeEnter</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
      component<span class="token operator">:</span> Foo<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p>组件内的守卫 <code>beforeRouteEnter(to, from, next)</code> <code>beforeRouteUpdate(to, from, next)</code> <code>beforeRouteLeave(to, from, next)</code></p> <p><code>beforeRouteEnter</code> 守卫 <mark>不能</mark> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。可以通过传一个回调给 <code>next</code> 来访问组件实例（其他两个都不支持回调，因为可以访问<code>this</code>了）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 `vm` 访问组件实例</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul> <p><strong>确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。</strong></p> <p>完整的导航解析流程</p> <ol><li>导航被触发</li> <li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫</li> <li>调用全局的 <code>beforeEach</code> 守卫</li> <li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)</li> <li>在路由配置里调用 <code>beforeEnter</code></li> <li>解析异步路由组件</li> <li>在被激活的组件里调用 <code>beforeRouteEnter</code></li> <li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)</li> <li>导航被确认</li> <li>调用全局的 <code>afterEach</code> 钩子</li> <li>触发 DOM 更新</li> <li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ol> <h2 id="vuerouter路由模式hash和history的实现原理"><a href="#vuerouter路由模式hash和history的实现原理" class="header-anchor">#</a> VueRouter路由模式hash和history的实现原理</h2> <ul><li>hash</li></ul> <p>使用 <code>URL</code> 的 <code>hash</code> 来模拟一个完整的 <code>URL</code>，于是当 <code>URL</code> 改变时，页面不会重新加载。 <code>hash</code>（<code>#</code>）是<code>URL</code> 的锚点，代表的是网页中的一个位置，单单改变<code>#</code>后的部分，不会重新加载网页，也就是说<code>hash</code> 出现在 <code>URL</code> 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面；同时每一次改变<code>#</code>后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说<code>Hash</code>模式通过锚点值的改变，根据不同的值，对页面进行跳转（渲染）。</p> <ul><li>history</li></ul> <p>利用了html5 history interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法。这两个方法应用于浏览器记录栈，在当前已有的 <code>back</code>、<code>forward</code>、<code>go</code> 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 <code>URL</code> ，但浏览器不会立即向后端发送请求。不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，可能就会返回 404，这就不好看了。所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 <code>URL</code> 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面。</p> <p>vue-router的<code>mode</code>除了<code>hash</code>和<code>history</code>之外还有一个模式：</p> <p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。(Node.js 环境)</p> <h2 id="vuerouter跳转的方式"><a href="#vuerouter跳转的方式" class="header-anchor">#</a> VueRouter跳转的方式</h2> <p><code>vm.$router</code>和<code>vm.$route</code>的区别</p> <ul><li><code>$router</code>是VueRouter创建的路由实例，上面包含了<code>beforeEach</code>,<code>beforeResolve</code>,<code>afterEach</code>,<code>push</code>,<code>replace</code>,<code>go</code>等等实例方法</li> <li><code>$route</code>返回的是一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象。里面包含<code>path</code>,<code>fullPath</code>,<code>params</code>,<code>query</code>,<code>hash</code>,<code>name</code>,<code>matched</code>(一个数组，包含当前路由的所有嵌套路径片段的路由记录 。路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。),<code>redirectedFrom</code>(如果存在重定向，即为重定向来源的路由的名字)</li></ul> <p>跳转实现</p> <ol><li><p>router-link</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>home<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ path: <span class="token punctuation">'</span>home<span class="token punctuation">'</span> }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ name: <span class="token punctuation">'</span>user<span class="token punctuation">'</span>, params: { userId: 123 }}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ path: <span class="token punctuation">'</span>register<span class="token punctuation">'</span>, query: { plan: <span class="token punctuation">'</span>private<span class="token punctuation">'</span> }}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Register<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code></p> <p>标签上其他的props</p> <ul><li>replace：更换为<code>router.replace()</code>：<code>&lt;router-link :to=&quot;{ path: '/abc'}&quot; replace&gt;&lt;/router-link&gt;</code></li> <li>append：设置 <code>append</code> 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 <code>/a</code> 导航到一个相对路径 <code>b</code>，如果没有配置 <code>append</code>，则路径为 <code>/b</code>，如果配了，则为 <code>/a/b</code></li> <li>tag：<code>tag prop</code> 类指定渲染成何种标签，默认 <code>a</code></li> <li>active-class：设置链接激活时使用的 CSS 类名，默认<code>router-link-active</code></li> <li>exact：“是否激活”默认类名的依据是包含匹配(即<code>/</code>这个路径任何时候都会激活)，加上这个精确匹配模式。</li> <li>event：声明可以用来触发导航的事件。默认<code>click</code></li> <li>exact-active-class：配置当链接被精确匹配的时候应该激活的 <code>class</code>，默认<code>router-link-exact-active</code></li> <li>aria-current-value：当链接根据精确匹配规则激活时配置的 <code>aria-current</code> 的值。默认<code>page</code></li></ul></li> <li><p>vm.$router.push</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 字符串</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">)</span>
<span class="token comment">// 对象</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'home'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 命名的路由</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId<span class="token operator">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 带查询参数，变成 /register?plan=private 会在地址栏显示参数 刷新不消失</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span> query<span class="token operator">:</span> <span class="token punctuation">{</span> plan<span class="token operator">:</span> <span class="token string">'private'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况，所以在使用时要<code>name</code>+<code>params</code>和<code>path</code>+<code>query</code>配合使用</strong></p> <p>还有一种传递参数的方式就是动态路由</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 动态路径参数 以冒号开头</span>
    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> User <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; /user/123</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>path</code>+<code>query</code>获取参数：<code>this.$route.query</code>，之外的都是<code>this.$route.params</code></p></li> <li><p>vm.$router.replace</p> <p>和<code>vm.$router.push</code>用法一样，跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 <code>history</code> 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 <code>history</code> 记录。</p></li></ol> <h2 id="不同路由使用相同组件缓存问题"><a href="#不同路由使用相同组件缓存问题" class="header-anchor">#</a> 不同路由使用相同组件缓存问题</h2> <p>多个路由解析到同一个 Vue 组件，使用相同组件的路由之间切换，则不会有任何改变</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span>
    component<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">'/b'</span><span class="token punctuation">,</span>
    component<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>要解决此问题，你需要在 <code>&lt;router-view&gt;</code> 元素上添加 <code>:key</code> 属性</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>$route.path<span class="token punctuation">'</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="props的验证"><a href="#props的验证" class="header-anchor">#</a> props的验证</h2> <p>官方文档：<a href="https://cn.vuejs.org/v2/api/#props" target="_blank" rel="nofollow noopener noreferrer">props<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>props</code>可以是数组或对象，用于接收来自父组件的数据。<code>props</code>可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p> <p>你可以基于对象的语法使用以下选项：</p> <ul><li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、<strong>任何自定义构造函数</strong>、或<strong>上述内容组成的数组</strong>。会检查一个<code>prop</code>是否是给定的类型，否则抛出警告。</li> <li><code>default</code>：<code>any</code> - 为该<code>prop</code>指定一个默认值。如果该<code>prop</code>没有被传入，则换做用这个值。对象或数组的默认值必须从一个<strong>工厂函数</strong>返回。</li> <li><code>required</code>：<code>Boolean</code> - 定义该<code>prop</code>是否是必填项。在非生产环境中，如果这个值为truthy且该<code>prop</code>没有被传入的，则一个控制台警告将会被抛出。</li> <li><code>validator</code>：<code>Function</code> - 自定义验证函数会将该<code>prop</code>的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个falsy的值(也就是验证失败)，一个控制台警告将会被抛出。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 简单语法</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'PropsDemoSimple'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'size'</span><span class="token punctuation">,</span> <span class="token string">'myMessage'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 对象语法，提供验证</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'PropsDemoAdvanced'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检测类型</span>
    height<span class="token operator">:</span> Number<span class="token punctuation">,</span>
    <span class="token comment">// 多个类型</span>
    width<span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 并没有 String | Number 这种写法</span>
    <span class="token comment">// 检测类型 + 其他验证</span>
    age<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      required<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function">validator</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意那些prop会在一个组件实例创建之前进行验证，所以实例的property(如<code>data</code>、<code>computed</code>等)在<code>default</code>或<code>validator</code>函数中是不可用的。</p></div> <p>P.S.：<code>$props</code>可以获取所有<code>props</code>，可以通过<code>v-bind=&quot;$props&quot;</code>全部传给子组件</p> <h2 id="watch的使用"><a href="#watch的使用" class="header-anchor">#</a> watch的使用</h2> <p>官方文档：<a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="nofollow noopener noreferrer">watch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>类型：<code>{ [key: string]: string | Function | Object | Array }</code></p> <p>详细：一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用<code>$watch()</code>，遍历watch对象的每一个property。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    c<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    d<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
    e<span class="token operator">:</span> <span class="token punctuation">{</span>
      f<span class="token operator">:</span> <span class="token punctuation">{</span>
        g<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  watch<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new: %s, old: %s'</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 方法名</span>
    b<span class="token operator">:</span> <span class="token string">'someMethod'</span><span class="token punctuation">,</span>
    <span class="token comment">// 该回调会在任何被侦听的对象的property改变时被调用，不论其被嵌套多深</span>
    c<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      deep<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token comment">// 打印oldVal和newVal值一样的原因是它们索引同一个对象/数组，深度监听</span>
      <span class="token comment">// 虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化。</span>
      <span class="token comment">// Vue不会保留修改之前值的副本</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 该回调将会在侦听开始之后被立即调用</span>
    d<span class="token operator">:</span> <span class="token punctuation">{</span>
      handler<span class="token operator">:</span> <span class="token string">'someMethod'</span><span class="token punctuation">,</span>
      immediate<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 你可以传入回调数组，它们会被逐一调用</span>
    e<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">'handle1'</span><span class="token punctuation">,</span>
      <span class="token keyword">function</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">handle3</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">/* ... */</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// watch vm.e.f's value: {g: 5} 通过字符串监听内部结构</span>
    <span class="token string">'e.f'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意，<strong>不应该使用箭头函数来定义watcher函数</strong> (例如<code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以<code>this</code>将不会按照期望指向Vue实例，<code>this.updateAutocomplete</code>将是<code>undefined</code>。</p> <p>methods里面的函数同理</p></div> <h2 id="vuex中为什么异步放在action-同步在mutation"><a href="#vuex中为什么异步放在action-同步在mutation" class="header-anchor">#</a> vuex中为什么异步放在action，同步在mutation</h2> <p><a href="https://www.zhihu.com/question/48759748/answer/112823337" target="_blank" rel="nofollow noopener noreferrer">来自尤雨溪的回答：<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>区分<code>actions</code>和<code>mutations</code>并不是为了解决竞态问题，而是为了能用devtools追踪状态变化。</p> <p>事实上在vuex里面<code>actions</code>只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发<code>mutation</code>就行。异步竞态怎么处理那是用户自己的事情。vuex真正限制你的只有<code>mutation</code>必须是同步的这一点（在<code>redux</code>里面就好像<code>reducer</code>必须同步返回下一个状态一样）。同步的意义在于这样每一个<code>mutation</code>执行完成后都可以对应到一个新的状态（和<code>reducer</code>一样），这样devtools就可以打个snapshot存下来，然后就可以随便time-travel了。如果你开着devtool调用一个异步的action，你可以清楚地看到它所调用的<code>mutation</code>是何时被记录下来的，并且可以立刻查看它们对应的状态。其实我有个点子一直没时间做，那就是把记录下来的<code>mutations</code>做成类似rx-marble那样的时间线图，对于理解应用的异步状态变化很有帮助。</p> <p>其实就是做了代码隔离，不非受控的代码集中到<code>action</code>，<code>mutation</code>只做纯函数的状态改变，mvvm一般强调的就是直接面对view的那层不要做复杂的逻辑</p> <h2 id="v-model绑定vuex中的数据报错如何处理"><a href="#v-model绑定vuex中的数据报错如何处理" class="header-anchor">#</a> v-model绑定vuex中的数据报错如何处理</h2> <p>官方文档：<a href="https://vuex.vuejs.org/zh/guide/forms.html" target="_blank" rel="nofollow noopener noreferrer">表单处理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>obj.message<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>v-model</code>的数据是双向的，但是vuex中的数据流是单向的，当输入值修改时，<code>v-model</code>是去修改<code>obj.message</code>，由于这个值在vuex中不是通过mutation提交的，所以会报错</p> <p>解决方法：</p> <ul><li>不使用<code>v-model</code>，使用<code>computed</code>计算值，通过<code>value</code>属性传给<code>input</code>，并且监听输入提交mutation</li> <li>使用<code>computed</code>属性的<code>getter</code>和<code>setter</code>，<code>get</code>方法用来获取值，<code>set</code>方法用来提交mutation修改状态</li></ul> <p>所以<code>v-model</code>的双向绑定与vuex的单向数据流并不冲突，两个所需要解决的场景不同，其实没有可比性</p> <h2 id="如何处理输入框中文输入校验问题"><a href="#如何处理输入框中文输入校验问题" class="header-anchor">#</a> 如何处理输入框中文输入校验问题</h2> <p>为了解决中文输入法输入内容时还没将中文插入到输入框就验证的问题，我们希望中文输入完成以后才验证</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>input<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@compositionstart</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleComposition<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@compositionupdate</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleComposition<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@compositionend</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleComposition<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>compositionstart</code>事件触发于一段文字的输入之前（类似于keydown事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词）</p> <p>简单来说就是切换中文输入法时在打拼音时（此时<code>input</code>内还没有填入真正的内容），会首先触发<code>compositionstart</code>，然后每打一个拼音字母，触发<code>compositionupdate</code>，最后将输入好的中文填入<code>input</code>中时触发<code>compositionend</code>。触发<code>compositionstart</code>时，文本框会填入“虚拟文本”（待确认文本），同时触发<code>input</code>事件；在触发compositionend时，就是填入实际内容后（已确认文本）,所以这里如果不想触发<code>input</code>事件的话就得设置一个bool变量来控制。</p> <h2 id="v-for是否需要事件委托"><a href="#v-for是否需要事件委托" class="header-anchor">#</a> v-for是否需要事件委托</h2> <p>首先我们需要知道事件委托主要有什么作用？</p> <ul><li>事件委托能够避免我们逐个的去给元素新增和删除事件</li> <li>事件委托比每一个元素都绑定一个事件性能要更好</li></ul> <p>事件委托作用主要是2个</p> <ul><li>将事件处理程序代理到父节点，减少内存占用率</li> <li>动态生成子节点时能自动绑定事件处理程序到父节点</li></ul> <p>结论</p> <ul><li>在<code>v-for</code>中，我们直接用一个for循环就能在模板中将每个元素都绑定上事件，并且当组件销毁时，vue也会自动给我们将所有的事件处理器都移除掉。所以事件委托能做到的第一点vue已经给我们做到了</li> <li>在<code>v-for</code>中，给元素绑定的都是相同的事件，所以除非上千行的元素需要加上事件，其实和使用事件委托的性能差别不大，所以也没必要用事件委托，只需要在没有委托的情况下真正发现任何性能问题时才使用它。</li></ul> <p><a href="https://forum.vuejs.org/t/is-event-delegation-necessary/3701" target="_blank" rel="nofollow noopener noreferrer">vue源码中并没有处理事件委托<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="react-vue的diff从o-n-3-到o-n-是怎么算出来"><a href="#react-vue的diff从o-n-3-到o-n-是怎么算出来" class="header-anchor">#</a> react,vue的diff从O(n^3)到O(n)是怎么算出来</h2> <ul><li>O(n^3)：具体不太清楚，大概是根据两棵树的编辑距离（tree edit distance），同时对比两棵树以及更新，时间复杂度大概在O(n<sup>3)，也有说树的最小距离编辑算法的时间复杂度是O(n</sup>2m(1+logmn))，m和n是两棵树的节点数，如果m和n同阶，就可以看做O(n^3)</li> <li>O(n)：代表如果有n节点需要更新，只需要操作dom n次就能完成。但是这里有个前提是这n个节点更新后和原来dom要在同层，如果跨层更新节点，肯定比O(n)复杂。</li></ul> <h2 id="vm-set-的原理"><a href="#vm-set-的原理" class="header-anchor">#</a> vm.$set()的原理</h2> <p>全局方法<code>Vue.set()</code>的别名</p> <p>Vue无法检测到对象属性的添加或删除。由于Vue会在初始化实例时对属性执行<code>getter</code>/<code>setter</code>转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。但是Vue提供了<code>Vue.set(object, propertyName, value)</code>/<code>vm.$set(object, propertyName, value)</code>来实现为对象添加响应式属性</p> <p>源码位置：vue/src/core/observer/index.js</p> <ul><li>如果目标是数组，直接使用数组的<code>splice</code>方法触发相应式；</li> <li>如果目标是对象，会先判断属性是否存在，如果存在直接修改该属性，判断对象是否是响应式，如果不是也是直接赋值，最终如果要对属性进行响应式处理，则是通过调用<code>defineReactive</code>方法进行响应式处理（<code>defineReactive</code>方法就是Vue在初始化对象时，给对象属性采用<code>Object.defineProperty</code>动态添加<code>getter</code>和<code>setter</code>的功能所调用的方法），并且调用设置对象下的<code>dep</code>对象上的<code>notify</code>通知</li></ul> <p>直接给一个数组项赋值，Vue不能检测到变化</p> <ol><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li> <li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol> <p>为了解决第一个问题，Vue提供了以下操作方法：</p> <ul><li><code>vm.$set(vm.items, indexOfItem, newValue)</code></li> <li><code>vm.items.splice(indexOfItem, 1, newValue)</code></li></ul> <p>为了解决第二个问题，Vue提供了以下操作方法：</p> <ul><li><code>vm.items.splice(newLength)</code></li></ul> <h2 id="自动导入文件"><a href="#自动导入文件" class="header-anchor">#</a> 自动导入文件</h2> <ul><li>手动一个个引入</li> <li>webpack提供的api <code>require.context</code></li></ul> <p><code>require.context</code>函数接受三个参数</p> <ul><li><code>directory {String}</code> -读取文件的路径</li> <li><code>useSubdirectories {Boolean}</code> -是否遍历文件的子目录</li> <li><code>regExp {RegExp}</code> -匹配文件的正则</li></ul> <p>语法: <code>require.context(directory, useSubdirectories = false, regExp = /^.//);</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> files <span class="token operator">=</span> require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.js$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
files<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'./index.js'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">...</span><span class="token function">files</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>default <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> obj<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="vue无法渲染以-和-开始的变量"><a href="#vue无法渲染以-和-开始的变量" class="header-anchor">#</a> Vue无法渲染以_和$开始的变量</h2> <p><a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="nofollow noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：实例创建之后，可以通过<code>vm.$data</code>访问原始数据对象。Vue实例也代理了data对象上所有的property，因此访问<code>vm.a</code>等价于访问<code>vm.$data.a</code>。以<code>_</code>或<code>$</code>开头的property<strong>不会</strong>被Vue实例代理，因为它们可能和Vue内置的property、API方法冲突。你可以使用例如<code>vm.$data._property</code>的方式访问这些property。</p> <p>注意：是不是响应式的跟有没有代理是两码事，如果是<code>_</code>或者<code>$</code>开头的变量没有被代理，但是在<code>$data</code>里面仍然是响应式的</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!-- 内容为空 --&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>{{ _aaa }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>{{ $bbb }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token comment">&lt;!-- 有内容 --&gt;</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>{{ $data._aaa }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>{{ $data.$bbb }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      _aaa<span class="token operator">:</span> <span class="token string">'_aaa'</span><span class="token punctuation">,</span>
      $bbb<span class="token operator">:</span> <span class="token string">'$bbb'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_aaa<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$bbb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined undefined</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">.</span>_aaa<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">.</span>$bbb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// _aaa $bbb</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_aaa <span class="token operator">=</span> <span class="token string">'1111'</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$bbb <span class="token operator">=</span> <span class="token string">'2222'</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">.</span>_aaa <span class="token operator">=</span> <span class="token string">'3333'</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">.</span>$bbb <span class="token operator">=</span> <span class="token string">'4444'</span><span class="token punctuation">;</span>
      <span class="token comment">// 定时器执行后，页面上四个值都显示出来了</span>
      <span class="token comment">// 如果只有前面两行，没有通过$data去修改，那么不会触发视图渲染</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>源码解析：<code>vue/src/core/instance/state.js</code></p> <ul><li><p><code>initData</code>函数，通过<code>isReserved</code>方法，判断是否是<code>$</code>或者<code>_</code>开头</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 源码地址：vue/src/core/util/lang.js</span>

<span class="token comment">/**
 * Check if a string starts with $ or _
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isReserved</span> <span class="token punctuation">(</span><span class="token parameter">str<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> c <span class="token operator">===</span> <span class="token number">0x24</span> <span class="token operator">||</span> c <span class="token operator">===</span> <span class="token number">0x5F</span>
  <span class="token comment">// ascii 36表示$ 95表示_</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>然后通过<code>proxy</code>去代理这个属性，成功代理的属性会直接以当前组件实例的属性出现</p></li> <li><p><code>vue/src/core/instance/proxy.js</code>定义访问和获取是检测是否代理的方法</p></li> <li><p><code>stateMixin</code>方法中将<code>$data</code>与<code>_data</code>关联起来，<code>Object.defineProperty(Vue.prototype, '$data', dataDef)</code>，所以<code>vm.a</code>和<code>vm.$data.a</code>是等价的</p></li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新: </span> <span class="time">2025年03月06日 15:35:02</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/pages/articles/interview/qian-duan-mian-shi-typescript.html" class="prev">
            前端面试-TypeScript
          </a></span> <span class="next"><a href="/pages/articles/interview/qian-duan-mian-shi-promise.html">
            前端面试-Promise
          </a></span></p></div> <div class="comments-wrapper" style="display:none;"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对vue的理解" class="sidebar-link reco-side-说说你对vue的理解" data-v-70334359>说说你对vue的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对spa-单页应用-的理解" class="sidebar-link reco-side-说说你对spa-单页应用-的理解" data-v-70334359>说说你对SPA（单页应用）的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对双向绑定的理解" class="sidebar-link reco-side-说说你对双向绑定的理解" data-v-70334359>说说你对双向绑定的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对vue生命周期的理解" class="sidebar-link reco-side-说说你对vue生命周期的理解" data-v-70334359>说说你对Vue生命周期的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue组件间通信方式都有哪些" class="sidebar-link reco-side-vue组件间通信方式都有哪些" data-v-70334359>Vue组件间通信方式都有哪些</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#为什么不用-root而要使用vuex呢" class="sidebar-link reco-side-为什么不用-root而要使用vuex呢" data-v-70334359>为什么不用$root而要使用vuex呢</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue中的v-show和v-if怎么理解" class="sidebar-link reco-side-vue中的v-show和v-if怎么理解" data-v-70334359>Vue中的v-show和v-if怎么理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#为什么vue中的v-if和v-for不建议一起用" class="sidebar-link reco-side-为什么vue中的v-if和v-for不建议一起用" data-v-70334359>为什么Vue中的v-if和v-for不建议一起用</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#spa首屏加载速度慢的怎么解决" class="sidebar-link reco-side-spa首屏加载速度慢的怎么解决" data-v-70334359>SPA首屏加载速度慢的怎么解决</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue中组件和插件有什么区别" class="sidebar-link reco-side-vue中组件和插件有什么区别" data-v-70334359>Vue中组件和插件有什么区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#为什么data属性是一个函数而不是一个对象" class="sidebar-link reco-side-为什么data属性是一个函数而不是一个对象" data-v-70334359>为什么data属性是一个函数而不是一个对象</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue中给对象添加新属性界面不刷新" class="sidebar-link reco-side-vue中给对象添加新属性界面不刷新" data-v-70334359>Vue中给对象添加新属性界面不刷新</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue实例挂载的过程中发生了什么" class="sidebar-link reco-side-vue实例挂载的过程中发生了什么" data-v-70334359>Vue实例挂载的过程中发生了什么</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue中的-nexttick有什么作用" class="sidebar-link reco-side-vue中的-nexttick有什么作用" data-v-70334359>Vue中的$nextTick有什么作用</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对vue的mixin的理解" class="sidebar-link reco-side-说说你对vue的mixin的理解" data-v-70334359>说说你对vue的mixin的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对slot的理解slot使用场景有哪些" class="sidebar-link reco-side-说说你对slot的理解slot使用场景有哪些" data-v-70334359>说说你对slot的理解slot使用场景有哪些</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue-observable你有了解过吗说说看" class="sidebar-link reco-side-vue-observable你有了解过吗说说看" data-v-70334359>Vue.observable你有了解过吗说说看</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#你知道vue中key的原理吗" class="sidebar-link reco-side-你知道vue中key的原理吗" data-v-70334359>你知道vue中key的原理吗</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说说你对keep-alive的理解" class="sidebar-link reco-side-说说你对keep-alive的理解" data-v-70334359>说说你对keep-alive的理解</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue常用的修饰符" class="sidebar-link reco-side-vue常用的修饰符" data-v-70334359>Vue常用的修饰符</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue自定义指令" class="sidebar-link reco-side-vue自定义指令" data-v-70334359>Vue自定义指令</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue中的过滤器" class="sidebar-link reco-side-vue中的过滤器" data-v-70334359>Vue中的过滤器</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#如何实现一个虚拟dom" class="sidebar-link reco-side-如何实现一个虚拟dom" data-v-70334359>如何实现一个虚拟DOM</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue项目中有封装过axios吗" class="sidebar-link reco-side-vue项目中有封装过axios吗" data-v-70334359>Vue项目中有封装过axios吗</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#有看过axios的源码吗" class="sidebar-link reco-side-有看过axios的源码吗" data-v-70334359>有看过axios的源码吗</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#ssr解决了什么问题有做过ssr吗" class="sidebar-link reco-side-ssr解决了什么问题有做过ssr吗" data-v-70334359>SSR解决了什么问题有做过SSR吗</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue开发过程你是怎么做接口管理的" class="sidebar-link reco-side-vue开发过程你是怎么做接口管理的" data-v-70334359>vue开发过程你是怎么做接口管理的</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#说下你的vue项目的目录结构" class="sidebar-link reco-side-说下你的vue项目的目录结构" data-v-70334359>说下你的vue项目的目录结构</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue要做权限管理该怎么做" class="sidebar-link reco-side-vue要做权限管理该怎么做" data-v-70334359>vue要做权限管理该怎么做</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue项目部署后报404是什么" class="sidebar-link reco-side-vue项目部署后报404是什么" data-v-70334359>vue项目部署后报404是什么</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#你是怎么处理vue项目中的错误的" class="sidebar-link reco-side-你是怎么处理vue项目中的错误的" data-v-70334359>你是怎么处理vue项目中的错误的</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue3跟vue2的区别吗" class="sidebar-link reco-side-vue3跟vue2的区别吗" data-v-70334359>Vue3跟Vue2的区别吗</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#object-defineproperty和proxy比较" class="sidebar-link reco-side-object-defineproperty和proxy比较" data-v-70334359>Object.defineProperty和Proxy比较</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue项目中的性能方面优化" class="sidebar-link reco-side-vue项目中的性能方面优化" data-v-70334359>vue项目中的性能方面优化</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#自定义组件的双向绑定怎么写" class="sidebar-link reco-side-自定义组件的双向绑定怎么写" data-v-70334359>自定义组件的双向绑定怎么写</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue双向绑定的sync" class="sidebar-link reco-side-vue双向绑定的sync" data-v-70334359>vue双向绑定的sync</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#数组有哪些api会改变原数组" class="sidebar-link reco-side-数组有哪些api会改变原数组" data-v-70334359>数组有哪些API会改变原数组</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#mvvm和mvc区别" class="sidebar-link reco-side-mvvm和mvc区别" data-v-70334359>MVVM和MVC区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue的父组件和子组件生命周期钩子函数执行顺序" class="sidebar-link reco-side-vue的父组件和子组件生命周期钩子函数执行顺序" data-v-70334359>Vue的父组件和子组件生命周期钩子函数执行顺序</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vuerouter有哪些钩子函数" class="sidebar-link reco-side-vuerouter有哪些钩子函数" data-v-70334359>VueRouter有哪些钩子函数</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vuerouter路由模式hash和history的实现原理" class="sidebar-link reco-side-vuerouter路由模式hash和history的实现原理" data-v-70334359>VueRouter路由模式hash和history的实现原理</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vuerouter跳转的方式" class="sidebar-link reco-side-vuerouter跳转的方式" data-v-70334359>VueRouter跳转的方式</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#不同路由使用相同组件缓存问题" class="sidebar-link reco-side-不同路由使用相同组件缓存问题" data-v-70334359>不同路由使用相同组件缓存问题</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#props的验证" class="sidebar-link reco-side-props的验证" data-v-70334359>props的验证</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#watch的使用" class="sidebar-link reco-side-watch的使用" data-v-70334359>watch的使用</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vuex中为什么异步放在action-同步在mutation" class="sidebar-link reco-side-vuex中为什么异步放在action-同步在mutation" data-v-70334359>vuex中为什么异步放在action，同步在mutation</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#v-model绑定vuex中的数据报错如何处理" class="sidebar-link reco-side-v-model绑定vuex中的数据报错如何处理" data-v-70334359>v-model绑定vuex中的数据报错如何处理</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#如何处理输入框中文输入校验问题" class="sidebar-link reco-side-如何处理输入框中文输入校验问题" data-v-70334359>如何处理输入框中文输入校验问题</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#v-for是否需要事件委托" class="sidebar-link reco-side-v-for是否需要事件委托" data-v-70334359>v-for是否需要事件委托</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#react-vue的diff从o-n-3-到o-n-是怎么算出来" class="sidebar-link reco-side-react-vue的diff从o-n-3-到o-n-是怎么算出来" data-v-70334359>react,vue的diff从O(n^3)到O(n)是怎么算出来</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vm-set-的原理" class="sidebar-link reco-side-vm-set-的原理" data-v-70334359>vm.$set()的原理</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#自动导入文件" class="sidebar-link reco-side-自动导入文件" data-v-70334359>自动导入文件</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html#vue无法渲染以-和-开始的变量" class="sidebar-link reco-side-vue无法渲染以-和-开始的变量" data-v-70334359>Vue无法渲染以_和$开始的变量</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:50%;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.a4a1bf2e.js" defer></script><script src="/assets/js/3.83a3aa92.js" defer></script><script src="/assets/js/1.1efd4ac0.js" defer></script><script src="/assets/js/63.48e809fc.js" defer></script><script src="/assets/js/11.a144a0bb.js" defer></script>
  </body>
</html>
