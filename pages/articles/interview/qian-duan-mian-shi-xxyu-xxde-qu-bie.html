<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试-XX与XX的区别 | frenchleave</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="冯春齐 fengchunqi frenchleave blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="keywords" content="冯春齐,fengchunqi,frenchleave blog">
    
    <link rel="preload" href="/assets/css/0.styles.fa1c3f8f.css" as="style"><link rel="preload" href="/assets/js/app.3cc15c65.js" as="script"><link rel="preload" href="/assets/js/3.7300aef9.js" as="script"><link rel="preload" href="/assets/js/1.cfd142c1.js" as="script"><link rel="preload" href="/assets/js/65.ca037216.js" as="script"><link rel="prefetch" href="/assets/js/10.4c13b9ab.js"><link rel="prefetch" href="/assets/js/100.d13108ea.js"><link rel="prefetch" href="/assets/js/101.2e9d0ace.js"><link rel="prefetch" href="/assets/js/102.7806e992.js"><link rel="prefetch" href="/assets/js/103.5c113d24.js"><link rel="prefetch" href="/assets/js/104.297c5388.js"><link rel="prefetch" href="/assets/js/105.4516214b.js"><link rel="prefetch" href="/assets/js/106.41ec9750.js"><link rel="prefetch" href="/assets/js/107.eec737f6.js"><link rel="prefetch" href="/assets/js/108.e774fda9.js"><link rel="prefetch" href="/assets/js/109.fe6a4d75.js"><link rel="prefetch" href="/assets/js/11.a515f43b.js"><link rel="prefetch" href="/assets/js/110.5692e48a.js"><link rel="prefetch" href="/assets/js/111.acb6b7ee.js"><link rel="prefetch" href="/assets/js/112.9a98b323.js"><link rel="prefetch" href="/assets/js/113.d6934473.js"><link rel="prefetch" href="/assets/js/114.19cfa21a.js"><link rel="prefetch" href="/assets/js/115.39aec867.js"><link rel="prefetch" href="/assets/js/116.7d88875e.js"><link rel="prefetch" href="/assets/js/117.56883b23.js"><link rel="prefetch" href="/assets/js/118.1d7bfe43.js"><link rel="prefetch" href="/assets/js/119.11ec6e23.js"><link rel="prefetch" href="/assets/js/12.e9187b87.js"><link rel="prefetch" href="/assets/js/120.c6639f49.js"><link rel="prefetch" href="/assets/js/121.6ac14790.js"><link rel="prefetch" href="/assets/js/122.58a8d7de.js"><link rel="prefetch" href="/assets/js/123.74f56114.js"><link rel="prefetch" href="/assets/js/124.93ad7c82.js"><link rel="prefetch" href="/assets/js/125.960525ef.js"><link rel="prefetch" href="/assets/js/126.efb142f9.js"><link rel="prefetch" href="/assets/js/127.92dca8be.js"><link rel="prefetch" href="/assets/js/128.e81dd02d.js"><link rel="prefetch" href="/assets/js/129.603a16fe.js"><link rel="prefetch" href="/assets/js/13.073e6450.js"><link rel="prefetch" href="/assets/js/130.e2b7b53f.js"><link rel="prefetch" href="/assets/js/131.4aab106c.js"><link rel="prefetch" href="/assets/js/132.9c79d992.js"><link rel="prefetch" href="/assets/js/133.918b97e3.js"><link rel="prefetch" href="/assets/js/134.7a46373f.js"><link rel="prefetch" href="/assets/js/135.323e5aba.js"><link rel="prefetch" href="/assets/js/136.9bae383e.js"><link rel="prefetch" href="/assets/js/137.9b5a2a61.js"><link rel="prefetch" href="/assets/js/138.38fe522b.js"><link rel="prefetch" href="/assets/js/139.745c47a1.js"><link rel="prefetch" href="/assets/js/14.dfebfba4.js"><link rel="prefetch" href="/assets/js/140.bfdad051.js"><link rel="prefetch" href="/assets/js/141.08af0f16.js"><link rel="prefetch" href="/assets/js/142.5f1a594f.js"><link rel="prefetch" href="/assets/js/143.ea5cf5b9.js"><link rel="prefetch" href="/assets/js/144.58c48a99.js"><link rel="prefetch" href="/assets/js/145.7d66dc72.js"><link rel="prefetch" href="/assets/js/15.51e59a06.js"><link rel="prefetch" href="/assets/js/16.7b4f9f2e.js"><link rel="prefetch" href="/assets/js/17.82323cc3.js"><link rel="prefetch" href="/assets/js/18.f31a0c3d.js"><link rel="prefetch" href="/assets/js/19.aedc093c.js"><link rel="prefetch" href="/assets/js/20.f4f125db.js"><link rel="prefetch" href="/assets/js/21.d40083aa.js"><link rel="prefetch" href="/assets/js/22.063faf67.js"><link rel="prefetch" href="/assets/js/23.62e12a94.js"><link rel="prefetch" href="/assets/js/24.2d06f92f.js"><link rel="prefetch" href="/assets/js/25.0ec5c7df.js"><link rel="prefetch" href="/assets/js/26.543b0289.js"><link rel="prefetch" href="/assets/js/27.34420cb5.js"><link rel="prefetch" href="/assets/js/28.ac4396af.js"><link rel="prefetch" href="/assets/js/29.618989b9.js"><link rel="prefetch" href="/assets/js/30.e1259029.js"><link rel="prefetch" href="/assets/js/31.c8ceff11.js"><link rel="prefetch" href="/assets/js/32.47c8e443.js"><link rel="prefetch" href="/assets/js/33.1e3cf846.js"><link rel="prefetch" href="/assets/js/34.95a1564a.js"><link rel="prefetch" href="/assets/js/35.41b6d653.js"><link rel="prefetch" href="/assets/js/36.44970978.js"><link rel="prefetch" href="/assets/js/37.40067c7d.js"><link rel="prefetch" href="/assets/js/38.a4f8f0ba.js"><link rel="prefetch" href="/assets/js/39.68d86d43.js"><link rel="prefetch" href="/assets/js/4.f1fcdff6.js"><link rel="prefetch" href="/assets/js/40.31e04ad2.js"><link rel="prefetch" href="/assets/js/41.eb1bc5dd.js"><link rel="prefetch" href="/assets/js/42.809752d1.js"><link rel="prefetch" href="/assets/js/43.390126d6.js"><link rel="prefetch" href="/assets/js/44.76357eed.js"><link rel="prefetch" href="/assets/js/45.6089512c.js"><link rel="prefetch" href="/assets/js/46.0dafc896.js"><link rel="prefetch" href="/assets/js/47.1e610091.js"><link rel="prefetch" href="/assets/js/48.963f5afc.js"><link rel="prefetch" href="/assets/js/49.97f1691f.js"><link rel="prefetch" href="/assets/js/5.9ed980da.js"><link rel="prefetch" href="/assets/js/50.ec2bca3d.js"><link rel="prefetch" href="/assets/js/51.cd5d4aff.js"><link rel="prefetch" href="/assets/js/52.5eea104b.js"><link rel="prefetch" href="/assets/js/53.2ace1604.js"><link rel="prefetch" href="/assets/js/54.3cf44288.js"><link rel="prefetch" href="/assets/js/55.2f23fbcf.js"><link rel="prefetch" href="/assets/js/56.2bd5c251.js"><link rel="prefetch" href="/assets/js/57.2286b767.js"><link rel="prefetch" href="/assets/js/58.9bf402e7.js"><link rel="prefetch" href="/assets/js/59.351e53a6.js"><link rel="prefetch" href="/assets/js/6.36581b04.js"><link rel="prefetch" href="/assets/js/60.6c541ed0.js"><link rel="prefetch" href="/assets/js/61.afcf4024.js"><link rel="prefetch" href="/assets/js/62.f39f2c79.js"><link rel="prefetch" href="/assets/js/63.cad8ae86.js"><link rel="prefetch" href="/assets/js/64.bbe0b103.js"><link rel="prefetch" href="/assets/js/66.77cd6dae.js"><link rel="prefetch" href="/assets/js/67.b892cb16.js"><link rel="prefetch" href="/assets/js/68.f6a8ae3f.js"><link rel="prefetch" href="/assets/js/69.334ff283.js"><link rel="prefetch" href="/assets/js/7.19c1e33e.js"><link rel="prefetch" href="/assets/js/70.f094f717.js"><link rel="prefetch" href="/assets/js/71.3c962286.js"><link rel="prefetch" href="/assets/js/72.67c919ba.js"><link rel="prefetch" href="/assets/js/73.b10a927c.js"><link rel="prefetch" href="/assets/js/74.b406f316.js"><link rel="prefetch" href="/assets/js/75.c33e56a4.js"><link rel="prefetch" href="/assets/js/76.39ca1235.js"><link rel="prefetch" href="/assets/js/77.a093259f.js"><link rel="prefetch" href="/assets/js/78.6a6a2a87.js"><link rel="prefetch" href="/assets/js/79.e95d2519.js"><link rel="prefetch" href="/assets/js/8.4b2dcb4b.js"><link rel="prefetch" href="/assets/js/80.18cb32c9.js"><link rel="prefetch" href="/assets/js/81.81052da3.js"><link rel="prefetch" href="/assets/js/82.9db7ae6b.js"><link rel="prefetch" href="/assets/js/83.9dcb98a9.js"><link rel="prefetch" href="/assets/js/84.67216dac.js"><link rel="prefetch" href="/assets/js/85.c3359191.js"><link rel="prefetch" href="/assets/js/86.350d6082.js"><link rel="prefetch" href="/assets/js/87.f624cbd4.js"><link rel="prefetch" href="/assets/js/88.b0148c21.js"><link rel="prefetch" href="/assets/js/89.2b1b427a.js"><link rel="prefetch" href="/assets/js/9.75709767.js"><link rel="prefetch" href="/assets/js/90.0072bf0a.js"><link rel="prefetch" href="/assets/js/91.25c4ec5f.js"><link rel="prefetch" href="/assets/js/92.94e7f310.js"><link rel="prefetch" href="/assets/js/93.eb1b0743.js"><link rel="prefetch" href="/assets/js/94.f7a55d15.js"><link rel="prefetch" href="/assets/js/95.09e5bb00.js"><link rel="prefetch" href="/assets/js/96.e5e1c2c3.js"><link rel="prefetch" href="/assets/js/97.612552e5.js"><link rel="prefetch" href="/assets/js/98.4ad263b4.js"><link rel="prefetch" href="/assets/js/99.b037f02d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fa1c3f8f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>frenchleave</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>冯春齐 fengchunqi frenchleave blog</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>fengchunqi</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.jpg" alt="frenchleave" class="logo"> <span class="site-name">frenchleave</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/About/" class="nav-link"><i class="undefined"></i>
  About
</a></li><li class="dropdown-item"><!----> <a href="/categories/Articles/" class="nav-link"><i class="undefined"></i>
  Articles
</a></li><li class="dropdown-item"><!----> <a href="/categories/Poem/" class="nav-link"><i class="undefined"></i>
  Poem
</a></li><li class="dropdown-item"><!----> <a href="/categories/Study/" class="nav-link"><i class="undefined"></i>
  Study
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="/pages/comments/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/about/author.html" class="nav-link"><i class="undefined"></i>
  关于作者
</a></li><li class="dropdown-item"><!----> <a href="/pages/about/website.html" class="nav-link"><i class="undefined"></i>
  关于本站
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    fengchunqi
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>117</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>20</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/About/" class="nav-link"><i class="undefined"></i>
  About
</a></li><li class="dropdown-item"><!----> <a href="/categories/Articles/" class="nav-link"><i class="undefined"></i>
  Articles
</a></li><li class="dropdown-item"><!----> <a href="/categories/Poem/" class="nav-link"><i class="undefined"></i>
  Poem
</a></li><li class="dropdown-item"><!----> <a href="/categories/Study/" class="nav-link"><i class="undefined"></i>
  Study
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="/pages/comments/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/about/author.html" class="nav-link"><i class="undefined"></i>
  关于作者
</a></li><li class="dropdown-item"><!----> <a href="/pages/about/website.html" class="nav-link"><i class="undefined"></i>
  关于本站
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/articles/interview/qian-duan-mian-shi-html.html" class="sidebar-link">前端面试-HTML</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-css.html" class="sidebar-link">前端面试-CSS</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-javascript.html" class="sidebar-link">前端面试-JavaScript</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-typescript.html" class="sidebar-link">前端面试-TypeScript</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-vue.html" class="sidebar-link">前端面试-Vue</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-promise.html" class="sidebar-link">前端面试-Promise</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-wang-luo-xiang-guan.html" class="sidebar-link">前端面试-网络相关</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html" aria-current="page" class="active sidebar-link">前端面试-XX与XX的区别</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-dai-ma-shu-chu.html" class="sidebar-link">前端面试-代码输出</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-zhu-guan-ti.html" class="sidebar-link">前端面试-主观题</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-gou-jian-gong-ju.html" class="sidebar-link">前端面试-构建工具</a></li><li><a href="/pages/articles/interview/qian-duan-mian-shi-react.html" class="sidebar-link">前端面试-React</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NPM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VSCode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>前端面试-XX与XX的区别</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>fengchunqi</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2024
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">前端面试-XX与XX的区别</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>fengchunqi</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2021/6/24</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>Interview</span></i></div></div> <div class="theme-reco-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIPS</p> <p>原文链接：<a href="https://juejin.cn/post/6956360277185003556" target="_blank" rel="nofollow noopener noreferrer">让我在面试官面前结巴的24个XX和XX的区别！<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="header-anchor">#</a> 箭头函数和普通函数的区别</h2> <ul><li>箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<code>=&gt;</code>定义函数,普通函数是<code>function</code>定义函数。</li> <li>箭头函数会捕获其所在上下文的<code>this</code>值，作为自己的<code>this</code>值，定义的时候就确定并固定了。</li> <li>箭头函数不能作为构造函数使用，也不能使用<code>new</code>关键字(因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会改变,作为构造函数其的<code>this</code>要是指向创建的新对象)。</li> <li>箭头函数没有自己的<code>arguments</code>。在箭头函数中访问<code>arguments</code>实际上获得的是外层局部（函数）执行环境中的值。</li> <li><code>call</code>、<code>apply</code>、<code>bind</code> 并不会影响其<code>this</code>的指向。</li> <li>箭头函数没有原型<code>prototype</code>。</li> <li>箭头函数不能当作<code>Generator</code>函数，不能使用<code>yield</code>关键字。</li></ul> <h2 id="var-let和const之间的区别"><a href="#var-let和const之间的区别" class="header-anchor">#</a> var,let和const之间的区别</h2> <ul><li><p>变量提升方面</p> <ul><li><code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为<code>undefined</code>。</li> <li><code>let</code>和<code>const</code>不存在变量提升问题(注意这个‘问题’后缀，其实是有提升的，只不过是<code>let</code>和<code>const</code>具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用)，即它们所声明的变量一定要在声明后使用，否则报错。</li></ul></li> <li><p>块级作用域方面</p> <ul><li><code>var</code>不存在块级作用域</li> <li><code>let</code>和<code>const</code>存在块级作用域</li></ul></li> <li><p>声明方面</p> <ul><li><code>var</code>允许重复声明变量</li> <li><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量。其中<code>const</code>声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。</li></ul></li></ul> <div class="custom-block tip"><p class="custom-block-title">TIPS</p> <p>如果<code>const</code>声明了一个对象obj，对象里的属性是可以改变的。</p> <p>因为<code>const</code>声明的obj只是保存着其对象的引用地址，只要地址不变，就不会出错。</p> <p>使用<code>Object.freeze(obj)</code>冻结obj,就能使其内的属性不可变,但它有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变，就需要使用递归等方式一层一层全部冻结。</p> <ul><li><p>var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来</p></li> <li><p>function：声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高</p></li> <li><p>let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行。const、class都是同let一样的道理</p></li> <li><p>var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针</p></li> <li><p>let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错</p></li> <li><p>const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性</p></li></ul></div> <h2 id="bigint和number的区别"><a href="#bigint和number的区别" class="header-anchor">#</a> Bigint和Number的区别</h2> <p><code>Number</code>类型的数字有精度限制，数值的精度只能到 53 个二进制位（相当于 16 个十进制位, 正负<code>9007199254740992</code>），大于这个范围的整数，就无法精确表示了。</p> <p><code>Bigint</code>没有位数的限制，任何位数的整数都可以精确表示。但是其只能用于表示整数，且为了与<code>Number</code>进行区分，<code>BigInt</code> 类型的数据必须添加后缀n。<code>BigInt</code> 可以使用负号（-），但是不能使用正号（+）。</p> <p>另外<code>Number</code>类型的数字和<code>Bigint</code>类型的数字不能混合计算。</p> <p><code>12n+12; //报错</code></p> <h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="header-anchor">#</a> 基本数据类型和引用数据类型的区别</h2> <ul><li><p>基本数据类型</p> <ul><li>基本数据类型的值是不可变的,这里你就可以联想到，<strong>是不是所有关于字符串和数字的方法都是带有返回值的，而不是改变原字符串或数字</strong>。</li> <li>基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回原基本数据类型，不会保存结果。</li> <li>基本数据类型的赋值是简单赋值,基本数据类型的比较是值的比较。</li> <li>基本数据类型是存放在栈区的</li></ul></li> <li><p>引用数据类型</p> <ul><li>引用类型的值是可以改变的,例如对象就可以通过修改对象属性值更改对象。</li> <li>引用类型可以添加属性和方法。</li> <li>引用类型的赋值是对象引用,即声明的变量标识符，存储的只是对象的指针地址。</li> <li>引用类型的比较是引用(指针地址)的比较。</li> <li>引用类型是同时保存在栈区和堆区中的,栈区保存变量标识符和指向堆内存的地址。</li></ul></li></ul> <h2 id="defer和async的区别"><a href="#defer和async的区别" class="header-anchor">#</a> defer和async的区别</h2> <p>大家应该都知道在<code>script</code>标签内有这两个属性<code>async</code>和<code>defer</code>，例如</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;xxx.js&quot;</span> async<span class="token operator">=</span><span class="token string">&quot;async&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;xxx.js&quot;</span> defer<span class="token operator">=</span><span class="token string">&quot;defer&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>defer：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。</li> <li>async：HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。</li></ul> <p><code>defer</code>：中文意思是延迟。用途是表示脚本会被延迟到<strong>整个页面都解析完毕后</strong>再运行。因此，在<code>&lt;script&gt;</code>元素中设置<code>defer</code>属性，相当于告诉浏览器立即下载，但延迟执行。</p> <p><code>HTML5</code>规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行,但执行脚本之间存在依赖，需要有执行的先后顺序时，就可以使用<code>defer</code>,延迟执行。我觉得把<code>script</code>脚本放在<code>body</code>底部和<code>defer</code>差不多。</p> <p><code>async</code>：中文意思是异步，这个属性与<code>defer</code>类似，都用于改变处理脚本的行为。同样与<code>defer</code>类似，<code>async</code>只适用于外部脚本文件，并告诉浏览器立即下载文件。但与<code>defer</code>不同的是，标记为<code>async</code>的脚本并不保证按照它们的先后顺序执行。</p> <p>指定<code>async</code>属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容,这使用于之间互不依赖的各脚本。</p> <p>看到这里，就能知道其的一些作用了</p> <p>当网页交给浏览器的<code>HTML</code>解析器转变成一系列的词语（<code>Token</code>）。解释器根据词语构建节点（<code>Node</code>），形成<code>DOM</code>树。因为<code>JavaScript</code>代码可能会修改<code>DOM</code>树的结构，所以节点是<code>JavaScript</code>代码的话，就需要停止当前<code>DOM</code>树的创建，直到<code>JavaScript</code>的资源加载并被<code>JavaScript</code>引擎执行后才继续<code>DOM</code>树的创建。</p> <p>这里就会产生阻塞，出现白屏问题(白屏问题优化有很多方面，这里就脚本阻塞这一小点)，我们就可以使用<code>async</code>和<code>defer</code>属性来解决<code>JavaScript</code>脚本阻塞问题。</p> <p>当然最稳妥的办法还是把<code>script</code>标签放置在<code>body</code>的底部，没有兼容性问题，不会因此产生白屏问题，没有执行顺序问题。</p> <h2 id="async-await对比promise的优缺点"><a href="#async-await对比promise的优缺点" class="header-anchor">#</a> async,await对比promise的优缺点</h2> <ul><li><p>async/await优点：</p> <ul><li>它做到了真正的串行的同步写法，代码阅读相对容易</li> <li>对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">222</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'yes, it is!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会打印</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>处理复杂流程时，在代码清晰度方面有优势</li></ul></li> <li><p>async/await缺点：</p> <ul><li>无法处理<code>promise</code>返回的<code>reject</code>对象，要借助<code>try/catch</code></li> <li>用<code>await</code>可能会导致性能问题，因为<code>await</code>会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// promise</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">ajax1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ajax2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><code>try/catch</code>内部的变量无法传递给下一个<code>try/catch</code>,<code>Promise</code>和<code>then/catch</code>内部定义的变量，能通过<code>then</code>链条的参数传递到下一个<code>then/catch</code>，但是<code>async/await</code>的<code>try</code>内部的变量，如果用<code>let</code>和<code>const</code>定义则无法传递到下一个<code>try/catch</code>，只能在外层作用域先定义好。</li></ul> <p>但<code>async/await</code>确确实实是解决了<code>promise</code>一些问题的。更加灵活的处理异步</p></li> <li><p>promise的一些问题：</p> <ul><li>一旦执行，无法中途取消，链式调用多个<code>then</code>中间不能随便跳出来</li> <li>错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</li> <li><code>Promise</code>内部如何执行，监测起来很难，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li></ul></li></ul> <h2 id="get和post的区别"><a href="#get和post的区别" class="header-anchor">#</a> GET和POST的区别</h2> <ul><li><p><code>GET</code> 是将参数写在 URL 中 <code>?</code> 的后面，并用 <code>&amp;</code> 分隔不同参数；而 <code>POST</code> 是将信息存放在 <code>Message Body</code> 中传送，参数‘不会’显示在 URL 中(Restful规范中是这样，但<code>POST</code>在有需要时可以把参数放URL里)。<code>GET</code>方式需要使用<code>Request.QueryString</code>来取得变量的值，而<code>POST</code>方式通过<code>Request.Form</code>来获取变量的值。也就是说<code>GET</code>是通过地址栏来传值，而<code>POST</code>是通过提交表单来传值。</p></li> <li><p><code>GET</code>请求提交的数据有长度限制（HTTP 协议本身没有限制 URL 及正文长度,对 URL 的限制大多是浏览器和服务器的原因），<code>POST</code>请求没有内容长度限制。</p></li> <li><p><code>GET</code>请求返回的内容会被浏览器缓存起来。而每次提交<code>POST</code>请求，浏览器不会缓存<code>POST</code>请求返回的内容。</p></li> <li><p><code>GET</code>对数据进行查询，<code>POST</code>主要对数据进行增删改！简单说，<code>GET</code>是只读，<code>POST</code>是写。</p></li> <li><p>关于安全性，<code>GET</code> 请求方式从浏览器的 URL 地址就可以看到参数；所以<code>POST</code>更安全，其实无论是 <code>GET</code> 还是 <code>POST</code> 其实都是不安全的，因为 HTTP 协议是明文传输，只要拦截封包便能轻易获取重要资讯。想要安全传输资料，必须使用<code>SSL/TLS</code>来加密封包，也就是 HTTPS。</p> <p>那为什么推崇使用<code>POST</code>来处理敏感数据呢？</p> <p>因为<code>GET</code>的记录会保存在浏览器，上网日志中，而使用<code>POST</code>，因为数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的安全性。</p></li> <li><p>一个误区 说<code>GET</code>产生一个TCP数据包；<code>POST</code>产生两个TCP数据包</p> <p>其说法：对于<code>GET</code>方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。</p> <p>对于<code>POST</code>方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再<code>POST</code>发送一个data给服务端，服务端响应200，请求成功。</p> <p>为其正名:上面所说的<code>POST</code>会比<code>GET</code>多一个TCP包其实不太严谨。多发的那个<code>expect 100 continue header</code>报文，是由客户端对http的<code>POST</code>和<code>GET</code>的请求策略决定的，目的是为了避免浪费资源，如带宽，数据传输消耗的时间等等。所以客户端会在发送header的时候添加expect 100去探探路，如果失败了就不用继续发送data，从而减少了资源的浪费。所以是否再发送一个包取决了客户端的实现策略，和<code>GET</code>/<code>POST</code>并没什么关系。有的客户端比如fireFox就只发送一个包。</p></li></ul> <p>扩展问题</p> <ol><li><p>请问<code>GET</code>请求能把参数传到body里面吗？</p> <p>答案是可以的。HTTP协议里说的是，<code>GET</code>是从服务器取回数据，<code>POST</code>是发送数据，HTTP请求有header，有body。但是实现怎么样，协议就不管了。HTTPClient，curl，postman，浏览器等这些都是实现，实现上并不保证能传输、接收<code>GET</code>的body数据。</p> <p>然而协议里确实说了哪些方法带body是没有意义并可能会产生问题，所以你硬给<code>GET</code>加一个body也是属于不遵循规范的，尽管可能成功但是后果自担。所以说<code>GET</code>不能带body是正确的说法。由于HTTP/1.1是基于文本的协议，所以头后空一行后的数据都是body，所以协议本身未作限制，但是有一个语义上的建议--不应在<code>GET</code>请求中放body。</p> <p>如果你尝试利用缓存，你可能会遇到问题。代理不会在<code>GET</code>正文中查看参数是否对响应产生影响。但是也可以使用ETag/Last-Modified头字段来辅助处理缓存。</p> <blockquote><p>The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
GET方法意味着检索由请求URI标识的任何信息（以实体的形式）。</p></blockquote></li> <li><p>在浏览器里如何让<code>GET</code>请求携带body呢？</p> <p>不行。从协议方面来说，<code>GET</code>是可以带body的，但是不赞成这么做，所以好多工具并没有去提供支持，例如postman选择<code>GET</code>请求时body选项禁用（新版本已经支持了）。基本上也不要用<code>GET</code>来携带body数据。XMLHttpRequest内部就把body给移除了，也就意味着ajax没戏。可以使用的好像有curl或者后端的某些请求。</p></li></ol> <h2 id="用框架和不用框架的区别-vue和react的区别"><a href="#用框架和不用框架的区别-vue和react的区别" class="header-anchor">#</a> 用框架和不用框架的区别,vue和react的区别</h2> <p>首先说说用框架和不用框架的区别：（以使用框架的角度看）</p> <p>框架好处：</p> <ul><li>使用框架工具写项目，在浏览器中代码依然是原生的HTML CSS JS。而框架帮开发者做了很多事情，开发者只关注业务逻辑就可以,极大的加快了开发速度。例如前端框架根本上是解决了UI 与状态同步问题,频繁操作 DOM 性能低下,中间步骤过多,易产生 bug且不易维护,而且心智要求较高不利于开发效率的一系列阻碍</li> <li>组件化: 其中以 <code>React</code> 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</li> <li>天然分层: <code>JQuery</code> 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li> <li>生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案</li></ul> <p>框架缺点：</p> <ul><li>代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。</li> <li>框架迭代更新速度非常快，需要时间熟悉它。</li></ul> <p>说说Vue和React的区别：</p> <ul><li><code>React</code>整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在<code>React</code>中，是单向数据流；</li> <li><code>Vue</code>的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立<code>Watcher</code>来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</li></ul> <h2 id="cookies和session的区别"><a href="#cookies和session的区别" class="header-anchor">#</a> cookies和session的区别</h2> <ul><li>存储位置不同:cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。</li> <li>存储容量不同:单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie，而对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</li> <li>存储方式不同:cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</li> <li>隐私策略不同:cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的，而session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。</li> <li>有效期上不同:开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为<code>JSESSIONID</code>的cookie，而cookie <code>JSESSIONID</code>的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</li> <li>服务器压力不同:cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li> <li>跨域支持上不同:cookie支持跨域名访问。session不支持跨域名访问。</li></ul> <h2 id="宏任务和微任务有什么区别"><a href="#宏任务和微任务有什么区别" class="header-anchor">#</a> 宏任务和微任务有什么区别</h2> <p><a href="/pages/articles/javascript/JavaScript中事件循环.html">JavaScript中事件循环</a></p> <h2 id="fetch-ajax-axios区别"><a href="#fetch-ajax-axios区别" class="header-anchor">#</a> fetch,Ajax,axios区别</h2> <ul><li><p>Ajax是什么：Ajax是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用<code>XMLHttpRequest</code>对象。</p></li> <li><p>axios是什么：axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p></li> <li><p>fetch是什么：Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比<code>XMLHttpRequest</code>更加简单易用。fetch不是ajax的进一步封装，而是原生js，没有使用<code>XMLHttpRequest</code>对象。</p> <ul><li><p>语法简洁，更加语义化</p></li> <li><p>基于标准 Promise 实现，支持 async/await</p></li> <li><p>同构方便，使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="nofollow noopener noreferrer">isomorphic-fetch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>更加底层，提供的API丰富（request, response）</p></li> <li><p>脱离了XHR，是ES规范里新的实现方式</p></li> <li><p>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</p></li> <li><p>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})</p></li> <li><p>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</p></li> <li><p>fetch没有办法原生监测请求的进度，而XHR可以</p></li></ul></li></ul> <p>主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// axios</span>
<span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  method<span class="token operator">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>
  url<span class="token operator">:</span> <span class="token string">'/user/12345'</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span>
    firstName<span class="token operator">:</span> <span class="token string">'Fred'</span><span class="token punctuation">,</span>
    lastName<span class="token operator">:</span> <span class="token string">'Flintstone'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// fetch</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oops, error&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="header-anchor">#</a> TCP和UDP的区别</h2> <ul><li>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。</li> <li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。并且因为 TCP 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。</li> <li>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</li> <li>TCP 只能是 1 对 1 的，而UDP 支持 1 对 1,1 对多。</li> <li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</li> <li>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</li></ul> <h2 id="js中的堆和栈-栈和队列有什么区别"><a href="#js中的堆和栈-栈和队列有什么区别" class="header-anchor">#</a> js中的堆和栈,栈和队列有什么区别</h2> <p>堆(heap)和栈(stack)的区别:</p> <ul><li>堆：队列优先,先进先出；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li> <li>栈：先进后出；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li></ul> <p>栈和队列的区别：</p> <ul><li>栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。</li> <li>栈是先进后出，队列是先进先出。</li></ul> <h2 id="websocket和http有什么区别"><a href="#websocket和http有什么区别" class="header-anchor">#</a> WebSocket和HTTP有什么区别</h2> <p>相同点</p> <ul><li>都是一样基于TCP的，都是可靠性传输协议。</li> <li>都是应用层协议。</li></ul> <p>不同点</p> <ul><li>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</li> <li>WebSocket是需要握手进行建立连接的。</li></ul> <h2 id="http和https的区别"><a href="#http和https的区别" class="header-anchor">#</a> HTTP和HTTPS的区别</h2> <ul><li>HTTP明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好。</li> <li>使用HTTPS协议需要到CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书较少，因而需要一定费用。</li> <li>HTTP页面响应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，所以一共是12个包。</li> <li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li> <li>HTTPS其实就是建构在SSL/TLS之上的HTTP协议，所以，要比较HTTPS比HTTP要更耗费服务器资源。</li></ul> <h2 id="px-em-rem-vw-vh区别"><a href="#px-em-rem-vw-vh区别" class="header-anchor">#</a> px,em,rem,vw,vh区别</h2> <ul><li>px: px就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的。</li> <li>em: 参考物是<strong>父元素</strong>的font-size，具有继承的特点。如果<strong>自身定义了font-size按自身来计算</strong>（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li> <li>rem: css3新单位，相对于**根元素html（网页）**的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。</li> <li>vw: css3新单位，viewpoint width的缩写，视窗宽度，1vw等于视窗宽度的1%。</li> <li>vh: css3新单位，viewpoint height的缩写，视窗高度，1vh等于视窗高度的1%。</li></ul> <h2 id="bind-call-apply区别"><a href="#bind-call-apply区别" class="header-anchor">#</a> bind,call,apply区别</h2> <ul><li>三者都可以改变函数的this对象指向。</li> <li>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window(node端指向global)。</li> <li>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</li> <li>bind改变this指向后不会立即执行，而是返回一个永久改变this指向的函数便于稍后调用；apply, call则是立即调用</li></ul> <h2 id="caller和callee的区别"><a href="#caller和callee的区别" class="header-anchor">#</a> caller和callee的区别</h2> <ul><li><p><code>Function.caller</code></p> <blockquote><p>非标准: 该特性是非标准的，请尽量不要在生产环境中使用它！</p></blockquote> <p>返回调用指定函数的函数。如果一个函数<code>f</code>是在全局作用域内被调用的，则<code>f.caller</code>为<code>null</code>，相反，如果一个函数是在另外一个函数作用域内被调用的，则<code>f.caller</code>指向调用它的那个函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">callerDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callerDemo<span class="token punctuation">.</span>caller<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> a <span class="token operator">=</span> callerDemo<span class="token punctuation">.</span>caller<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this is a top function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">handleCaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">callerDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">handleCaller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;function handleCaller() { callerDemo();}&quot;</span>
<span class="token function">callerDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this is a top function</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li> <li><p><code>arguments.callee</code></p> <p><code>callee</code>是<code>arguments</code>对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。这在函数的名称是未知时很有用，例如在没有名称的函数表达式(也称为“匿名函数”)内。</p> <blockquote><p>警告：在严格模式下，第5版 ECMAScript (ES5) 禁止使用 arguments.callee()。当一个函数必须调用自身的时候, 避免使用 arguments.callee(), 通过要么给函数表达式一个名字,要么使用一个函数声明.</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">calleeDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">calleeDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回函数 function calleeDemo() {console.log(arguments.callee);}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul> <h2 id="_301和302有什么区别"><a href="#_301和302有什么区别" class="header-anchor">#</a> 301和302有什么区别</h2> <ul><li>301 Moved Permanently: 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</li> <li>302 Found: 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。</li></ul> <p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。</p> <p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转, 比如未登陆的用户访问用户中心被重定向到登录页面</p> <h2 id="进程线程协程的区别"><a href="#进程线程协程的区别" class="header-anchor">#</a> 进程线程协程的区别</h2> <p><a href="/pages/articles/linux/进程线程协程.html">进程线程协程</a></p> <h2 id="javascript和typescript的区别"><a href="#javascript和typescript的区别" class="header-anchor">#</a> JavaScript和TypeScript的区别</h2> <ul><li>TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。</li> <li>JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。</li> <li>TypeScript 通过类型注解提供编译时的静态类型检查。</li> <li>TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</li> <li>TypeScript 为函数提供了缺省参数值。</li> <li>TypeScript 引入了 JavaScript 中没有的“类”概念。</li> <li>TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</li></ul> <h2 id="localstorage-sessionstorage-cookie的区别"><a href="#localstorage-sessionstorage-cookie的区别" class="header-anchor">#</a> localstorage,sessionstorage,cookie的区别</h2> <ul><li>相同点是都是保存在浏览器端、且同源的</li> <li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li> <li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li> <li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li> <li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</li> <li>webStorage(webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage)支持事件通知机制，可以将数据更新的通知发送给监听者</li> <li>webStorage的api接口使用更方便</li></ul> <h2 id="http1-0-1-1-2-0的不同"><a href="#http1-0-1-1-2-0的不同" class="header-anchor">#</a> HTTP1.0/1.1/2.0的不同</h2> <p><a href="/pages/articles/http/HTTP1.0,1.1,2.0的区别.html">HTTP1.0,1.1,2.0的区别</a></p> <h2 id="mongodb和mysql的区别"><a href="#mongodb和mysql的区别" class="header-anchor">#</a> MongoDB和MySQL的区别</h2> <table><thead><tr><th>数据库</th> <th>MongoDB</th> <th>MySQL</th></tr></thead> <tbody><tr><td>数据库模型</td> <td>非关系型</td> <td>关系型</td></tr> <tr><td>存储方式</td> <td>以类JSON的文档的格式存储</td> <td>不同引擎有不同的存储方式</td></tr> <tr><td>查询语句</td> <td>MongoDB查询方式（类似JavaScript的函数）</td> <td>SQL语句</td></tr> <tr><td>数据处理方式</td> <td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td> <td>不同引擎有自己的特点</td></tr> <tr><td>成熟度</td> <td>新兴数据库，成熟度较低</td> <td>成熟度高</td></tr> <tr><td>广泛度</td> <td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td> <td>开源数据库，市场份额不断增长</td></tr> <tr><td>事务性</td> <td>仅支持单文档事务操作，弱一致性</td> <td>支持事务操作</td></tr> <tr><td>占用空间</td> <td>占用空间大</td> <td>占用空间小</td></tr> <tr><td>join操作</td> <td>MongoDB没有join</td> <td>MySQL支持join</td></tr></tbody></table> <h2 id="width的100-与auto的区别"><a href="#width的100-与auto的区别" class="header-anchor">#</a> width的100%与auto的区别</h2> <p>width: auto</p> <ul><li>子元素（包括content+padding+border+margin）撑满整个父元素的content区域</li> <li>子元素有margin、border、padding时，会减去子元素content区域相对应的width值</li> <li>父元素的content = 子元素（content + padding + border + margin）</li></ul> <p>width: 100%</p> <ul><li>强制将子元素的content区域 撑满 父元素的content区域</li> <li>子元素有margin、border、padding时，不改变子元素content区域的width，而是溢出父盒子，保持原有值</li> <li>父元素的content = 子元素的content</li></ul> <h2 id="标准盒模型和怪异盒模型的区别"><a href="#标准盒模型和怪异盒模型的区别" class="header-anchor">#</a> 标准盒模型和怪异盒模型的区别</h2> <p><code>box-sizing: content-box;</code>(默认值)</p> <p>标准盒模型，又叫W3C标准盒模型：<code>contentWidth = width</code>，即此时的宽高是内容区的宽高</p> <p><code>box-sizing: border-box;</code></p> <p>怪异盒模型，又叫IE6混杂盒模型：<code>contentWidth = width - 2*padding - 2*border</code>，即此时的宽高包括了padding和border，内容区的宽高需减去两侧padding和border</p> <h2 id="display-none和visibility-hidden和opacity-0的区别"><a href="#display-none和visibility-hidden和opacity-0的区别" class="header-anchor">#</a> display:none和visibility:hidden和opacity:0的区别</h2> <ul><li><code>display: none</code>隐藏后的元素不占据任何空间，而<code>visibility: hidden</code>隐藏后的元素空间依旧保留，<code>opacity: 0</code>隐藏后也占空间</li> <li>只有<code>opacity: 0</code>依旧会监听事件，其余两个隐藏后无法监听事件</li> <li><code>visibility</code>具有继承性，给父元素设置<code>visibility: hidden;</code>子元素也会继承这个属性。但是如果重新给子元素设置<code>visibility: visible</code>,则子元素又会显示出来。<code>display: none</code>和<code>opacity</code>都不能继承，有株连性</li> <li><code>visibility: hidden</code>和<code>opacity: 0</code>不会影响计数器的计数，例如在一组ol,li列表中隐藏某一个li元素，<code>visibility: hidden</code>和<code>opacity: 0</code>虽然让一个元素不见了，但是其计数器仍在运行。这和<code>display: none</code>完全不一样</li> <li>CSS3的<code>transition</code>支持<code>visibility</code>和<code>opacity</code>属性，但是并不支持<code>display</code>，由于<code>transition</code>可以延迟执行，因此可以配合<code>visibility</code>使用纯css实现<code>hover</code>延时显示效果。<code>visibility</code>会立即显示，隐藏时会延时，<code>opacity</code>可以延时显示和隐藏</li> <li><code>display: none</code>会触发<code>reflow</code>和<code>repaint</code>，但是<code>visibility: hidden</code>只会触发<code>repaint</code>，<code>opacity: 0</code>会触发css3硬件加速，不触发回流重绘，大大减少性能消耗</li></ul> <h2 id="sass和less的区别"><a href="#sass和less的区别" class="header-anchor">#</a> Sass和Less的区别</h2> <p>相同之处</p> <ul><li>混入(Mixins)——class中的class；</li> <li>参数混入——可以传递参数的class，就像函数一样，Sass用逗号分隔参数，Less用分号；</li> <li>嵌套规则——class中嵌套class，从而减少重复的代码；</li> <li>运算——CSS中用上数学；</li> <li>颜色功能——可以编辑颜色；</li> <li>名字空间(namespace)——分组样式，从而可以被调用；</li> <li>作用域——局部修改样式；</li> <li>JavaScript赋值——在CSS中使用JavaScript表达式赋值。</li></ul> <p>不同之处</p> <ul><li>环境不同：Sass基于Ruby写的，服务端处理，Less基于Node写的，客户端处理</li> <li>变量命名：Sass使用<code>$</code>，Less使用<code>@</code></li> <li>输出设置，Less没有输出设置，Sass提供4中输出选项：nested（嵌套，默认格式）, compact（紧密型，每条样式占一行）, compressed（压缩） 和 expanded（像是手写的样式）。</li> <li>Sass支持条件语句，可以使用<code>@if{}</code>、<code>@else{}</code>、<code>@for{}</code>、<code>@each</code>、<code>@while</code>循环、<code>@extend</code>继承、<code>@import引</code>用等等，而Less不支持。</li> <li>Sass支持数据结构：<code>@list</code>数组、<code>@map</code>对象，也包括<code>string</code>，<code>number</code>，<code>function</code></li></ul> <h2 id="sass中-include和-extend的区别"><a href="#sass中-include和-extend的区别" class="header-anchor">#</a> Sass中@include和@extend的区别</h2> <ul><li><code>@include</code>是引入<code>@mixin</code>定义的混合，会直接把<code>@mixin</code>里面的代码拷贝到<code>@include</code>里面，可能会导致生成重复的样式，并没有起到提取公用的效果，导致生成的CSS过大</li> <li><code>@extend</code>是将一个选择器下的所有样式继承给另一个选择器，相同的样式编译后只会出现一次</li></ul> <p>扩展：<code>%</code>定义占位符选择器，不会被编译到CSS文件中</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code><span class="token selector"><span class="token placeholder">%log</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.log-debug </span><span class="token punctuation">{</span>
  <span class="token keyword">@extend</span> <span class="token placeholder selector">%log</span><span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.log-error </span><span class="token punctuation">{</span>
  <span class="token keyword">@extend</span> <span class="token placeholder selector">%log</span><span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 3px dotted red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>编译后</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code><span class="token selector">.log-error, .log-debug </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.log-debug </span><span class="token punctuation">{</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.log-error </span><span class="token punctuation">{</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 3px dotted red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="css中link和-import的区别"><a href="#css中link和-import的区别" class="header-anchor">#</a> CSS中link和@import的区别</h2> <ul><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持（IE5以上才能识别）。</li> <li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li> <li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li> <li>可以通过JS操作DOM，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。</li> <li>link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC（浏览器样式闪烁或者叫做无样式内存闪烁）</li> <li>link方式的样式的权重高于@import的权重。</li></ul> <p>不太理解网上都说的这个link方式引入的样式权重更高。</p> <ol><li><p>如果是单纯的两个分开写，在head标签里面写两个引入，哪个在后面哪个生效，这个和普通的权重判断一样</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>1.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>2.css<span class="token punctuation">)</span></span><span class="token punctuation">;</span></span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>如果是link的文件里面同时写了@import，此时的@import必须写在文件顶部才能生效，后面如果存在相同样式，会覆盖掉@import中引入的，即便它是后加载进来的，可能是因为这个有人说link的权重更高吧</p></li></ol> <p>@import最优写法</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token comment">/* Windows IE4/ NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别 */</span>
  <span class="token atrule"><span class="token rule">@import</span> <span class="token string">'style.css'</span><span class="token punctuation">;</span></span>
  <span class="token comment">/* Windows IE4/ NS4, Macintosh IE4/NS4不识别 */</span>
  <span class="token atrule"><span class="token rule">@import</span> <span class="token string">&quot;style.css&quot;</span><span class="token punctuation">;</span></span>
  <span class="token comment">/* Windows NS4, Macintosh NS4不识别 */</span>
  <span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>style.css<span class="token punctuation">)</span></span><span class="token punctuation">;</span></span>
  <span class="token comment">/* Windows NS4, Mac OS X IE5, Macintosh IE4/IE5/NS4不识别 */</span>
  <span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">'style.css'</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span></span>
  <span class="token comment">/* Windows NS4, Macintosh NS4不识别 */</span>
  <span class="token atrule"><span class="token rule">@import</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">&quot;style.css&quot;</span><span class="token punctuation">)</span></span><span class="token punctuation">;</span></span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>由上分析知道，<code>@import url(style.css)</code> 和<code>@import url(&quot;style.css&quot;)</code>是最优的选择，兼容的浏览器最多。从字节优化的角度来看<code>@import url(style.css)</code>最值得推荐。</p> <h2 id="浏览器和node事件循环的区别"><a href="#浏览器和node事件循环的区别" class="header-anchor">#</a> 浏览器和Node事件循环的区别</h2> <p>参考文章：<a href="https://www.zhihu.com/question/268007969" target="_blank" rel="nofollow noopener noreferrer">async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>其中一个主要的区别在于浏览器的<code>event loop</code>和<code>nodejs</code>的<code>event loop</code> 在处理异步事件的顺序是不同的。<code>nodejs</code>中有<code>micro event</code>;其中<code>Promise</code>属于<code>micro event</code> 该异步事件的处理顺序就和浏览器不同。</p> <p><code>nodejs</code> V11.0以前，<code>nodejs</code>的事件队列会先处理的宏任务，之后的版本这两者之间的顺序就相同了，产生差异的根本原因是V8引擎的区别，而不是浏览器与Node的区别。</p> <blockquote><p>一般来说，当遇到Chrome和Node.js在JavaScript运行方面有差异，应以最新的Chrome的行为为准。虽然Chrome和Node.js都使用V8为其JavaScript引擎，但两者的V8更新策略不同。Chrome每次升级会同时更新到V8的最新版。而Node更新小版本时V8也只更新小版本，只有Node更新大版本时才会更新V8大版本。所以绝大部分时候Node的V8会比同时期的Chrome的V8要落后。</p> <p>来自贺师俊</p></blockquote> <ul><li>Node端，<code>microtask</code> 在事件循环的各个阶段之间执行。执行一个宏任务时会把里面的代码执行完之后，产生的微任务并不会在此轮事件循环中执行，而是会去执行下一个宏任务，宏任务执行完后再回到微任务队列执行微任务</li> <li>浏览器端，<code>microtask</code> 在事件循环的 <code>macrotask</code> 执行完之后执行，即每当一个宏任务执行完成后，在执行下一个宏任务之前会清空当前的微任务队列，即使再次产生了微任务，即必须保证在执行下一次宏任务时，微任务队列是空的</li></ul> <h2 id="gif-jpg-png-webp的区别"><a href="#gif-jpg-png-webp的区别" class="header-anchor">#</a> gif,jpg,png,webp的区别</h2> <p>参考文章：<a href="https://blog.csdn.net/weixin_44022064/article/details/103823368" target="_blank" rel="nofollow noopener noreferrer">聊一聊几种常用web图片格式：gif、jpg、png、webp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <table><thead><tr><th>格式</th> <th>优点</th> <th>缺点</th> <th>适用场景</th></tr></thead> <tbody><tr><td>gif</td> <td>文件小，支持动画、透明，无兼容性问题</td> <td>只支持256(2^8)种颜色</td> <td>色彩简单的logo、icon、动图</td></tr> <tr><td>jpg</td> <td>色彩丰富，文件小</td> <td>有损压缩，反复保存图片质量下降明显</td> <td>色彩丰富的图片/渐变图像</td></tr> <tr><td>png</td> <td>无损压缩，支持透明，简单图片尺寸小</td> <td>不支持动画，色彩丰富的图片尺寸大</td> <td>logo/icon/透明图</td></tr> <tr><td>webp</td> <td>文件小，支持有损和无损压缩，支持动画、透明</td> <td>浏览器兼容性不好</td> <td>支持webp格式的app和webview</td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">TIPS</p> <p>JPG与JPEG的区别：</p> <p>没有区别。全名、正式扩展名是JPEG。但因DOS、Windows 95等早期系统采用的8.3命名规则只支持最长3字符的扩展名，为了兼容采用了.jpg。也因历史习惯和兼容性考虑，.jpg目前更流行。类似html和htm的区别</p></div> <h2 id="isnan与number-isnan的区别"><a href="#isnan与number-isnan的区别" class="header-anchor">#</a> isNaN与Number.isNaN的区别</h2> <ul><li><code>isNaN()</code>是ES5的方法，<code>Number.isNaN()</code>是ES6的方法</li> <li>可能有人会认为<code>isNaN()</code>直译为“是不是NaN”，其本意不是，<code>isNaN()</code>本意是通过Number方法把参数转换成数字类型，如若转换成功，则返回false，反之返回true，它只是判断参数是否能转成数字，不能用来判断是否严格等于NaN。如果要判断某个值是否严格等于NaN不能用这个方法</li> <li>ES6提供了<code>Number.isNaN()</code>方法用来判断一个值是否严格等于NaN，它会首先判断传入的值是否为数字类型，如不是，直接返回false。不会出现类型转换</li></ul> <ol><li><p>为什么NaN !== NaN</p> <p>NaN只是Number上的一个静态属性。比如<code>Number('echo')</code>会得到NaN，它只是为了告诉你这个值不是一个数字，一种表示方法，而非一个精准有效的值，因此NaN不能参与计算，也无法与自身比较。</p></li> <li><p>什么情况下产生NaN</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 当Number提供的类型转换方法在解析一个值却无法返回数字时</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'echo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>

<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'echo123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'123echo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>

<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'时间跳跃123.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'123.1时间跳跃'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123.1</span>

<span class="token comment">// 计算中使用- / *运算符，参与计算的值转换类型失败时</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token string">'听风是风'</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token number">1</span> <span class="token operator">*</span> <span class="token string">'123时间跳跃'</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token number">1</span> <span class="token operator">/</span> <span class="token string">'echo123'</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>

<span class="token comment">// 两个数字0相除也会得到NaN</span>
<span class="token number">0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Infinity</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p>isNaN方法的含义，如何判断一个值严格等于NaN</p> <p>全局方法<code>isNaN()</code>会先把传入的参数调用一次<code>Number()</code>，只是判断这个参数能不能转换成数字，如果能返回false，不能返回true，比如传入非数字开头的字符串会返回true</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'qweqwe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'qweqwe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>手动实现</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// MDN提供的Polyfill</span>
<span class="token keyword">function</span> <span class="token function">isNaN1</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// NaN是JS中唯一一个自身不相等的存在</span>
<span class="token keyword">function</span> <span class="token function">isNaN2</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value <span class="token operator">!==</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <div class="custom-block tip"><p class="custom-block-title">TIPS</p> <p>相同的ES6提供的<code>Number.isFinite(value)</code>与全局<code>isFinite()</code>目的一样，是为了解决全局方法会对传入的参数进行转换</p> <p>和全局的 <code>isFinite()</code> 函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token number">2e64</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, would've been true with global isFinite('0')</span>
Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, would've been true with global isFinite(null)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>MDN提供的Polyfill</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isFinite1</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isFinite</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></div> <h2 id="观察者模式与发布订阅模式的区别"><a href="#观察者模式与发布订阅模式的区别" class="header-anchor">#</a> 观察者模式与发布订阅模式的区别</h2> <p>观察者模式(Observer pattern)，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主体对象在状态变化时，会通知所有的观察者对象。</p> <p>发布-订阅模式(Publish–subscribe pattern)，消息的发送方，叫做发布者（publishers），消息不会直接发送给特定的接收者，叫做订阅者。意思就是发布者和订阅者不知道对方的存在。需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息。换句话说，发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在。需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来。</p> <h2 id="eslint和prettier的区别"><a href="#eslint和prettier的区别" class="header-anchor">#</a> ESLint和Prettier的区别</h2> <p>参考文章：<a href="https://juejin.cn/post/6844904159670435854" target="_blank" rel="nofollow noopener noreferrer">彻底搞清楚ESLint和Prettier的职责关系<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>ESLint、StyleLint、TSLint(已废弃)都属于Linters，它们通过对代码的AST进行分析，并按照一系列可配置的规则，为用户提供代码校验的功能。他们的规则主要分为两大类：Formatting Rules和Code-quality Rules。通常，Linters的客户端还会提供修复功能(--fix)，我们常用的IDE借助这些客户端便可以实现代码自动修复的功能</p> <p>Linters的自动修复是基于上述两种规则：Formatting和Code-quality。在Code-quality上，Linters做的做够好了，像no-unused-vars、no-extra-bind、no-undef等。但是在Formatting上，Linters虽然能在一定程度上保证代码的格式，像max-len、no-mixed-spaces-and-tabs、keyword-spacing等, 但是在书写工业化代码的时候，我们会有更高的要求：保证团队的代码风格完全一致。</p> <p>在不超出max-len的条件下，如下两种写法Linters都是允许的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 小明写的</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">}</span> <span class="token operator">=</span> obj
<span class="token comment">// 小李写的</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">,</span>
  b<span class="token punctuation">,</span>
  c<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token operator">=</span> obj
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Prettier是一个多语言支持的代码格式化工具，它也是通过AST解析代码，然后以一个特定的格式输出格式化后的代码。相比Linters，Prettier没有那么多针语言语法的规则，而是一个纯粹的代码格式化工具，在Prettier看来，任何东西都是可以格式化的。</p> <p>如何解决两者规则冲突问题</p> <p>有两种思路：</p> <ol><li>先用Prettier格式化，再用Linters格式化</li> <li>使用Linters按照Prettier的规则格式化（最佳实践）</li></ol> <p>对于第1种思路，一般是使用<code>prettier-eslint</code>这个库，按照code -&gt; prettier -&gt; eslint --fix的流程格式化代码，因此它不得不格式化两次才能完成操作，会有性能问题，所以目前已经不推荐这个方案了。</p> <p>第2种，Prettier将会作为Linters中Formatting Rules的完全替代品参与到代码格式化的过程中。为了达成这个目标，我们有两件事需要做：</p> <ul><li>禁用掉Linters中所有与Prettier冲突的Formatting Rules</li> <li>针对Prettier自身的规则，使用Prettier进行格式化</li></ul> <h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="header-anchor">#</a> 正向代理和反向代理</h2> <p>参考文章：<a href="https://zhuanlan.zhihu.com/p/69072041" target="_blank" rel="nofollow noopener noreferrer">什么是正向代理与反向代理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>正向代理是从客户端的角度出发，服务于特定用户（比如说一个局域网内的客户）以访问非特定的服务；反向代理正好与此相反，从服务端的角度出发，服务于非特定用户（通常是所有用户），已访问特定的服务。</p> <p>为什么使用代理服务器？</p> <ul><li>提高访问速度：由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度。</li> <li>防火墙作用：由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</li> <li>突破访问限制：互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</li></ul> <p>正向代理（forward proxy），一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。</p> <p>A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。</p> <p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。</p> <p>A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。</p> <p>正向代理和反向代理的区别</p> <p>位置不同</p> <ul><li>正向代理，架设在客户机和目标主机之间；</li> <li>反向代理，架设在服务器端；</li></ul> <p>代理对象不同</p> <ul><li>正向代理，代理客户端，服务端不知道实际发起请求的客户端；</li> <li>反向代理，代理服务端，客户端不知道实际提供服务的服务端；</li></ul> <h2 id="crlf-lf-cr的区别"><a href="#crlf-lf-cr的区别" class="header-anchor">#</a> CRLF,LF,CR的区别</h2> <ul><li><p>CR：Carriage Return，对应ASCII中转义字符<code>\r</code>，表示回车</p></li> <li><p>LF：Linefeed，对应ASCII中转义字符<code>\n</code>，表示换行</p></li> <li><p>CRLF：Carriage Return &amp; Linefeed，<code>\r\n</code>，表示回车并换行</p></li> <li><p>Windows操作系统采用两个字符来进行换行，即CRLF；</p></li> <li><p>Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；</p></li> <li><p>另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p></li></ul> <p>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p> <p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p> <p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p> <p>LF和CRLF之间的不同经常会导致不同会导致使用不同系统的同事之间的代码冲突问题。在你使用git拉取代码的时候，git会自动将代码当中与你当前系统不同的换行方式转化成你当前系统的换行方式，从而造成这种冲突。</p> <p>window系统解决办法：</p> <ol><li><p>修改git全局配置，禁止git自动将LF转换成CRLF,  命令：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global core.autocrlf <span class="token boolean">false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>修改编辑器的用户配置，例如<code>.vscode/setting.json</code></p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token property">&quot;files.eol&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 文件换行使用LF方式</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><code>.editorconfig</code>文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>end_of_line = lf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><code>.gitattributes</code> 配置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>* text=auto eol=lf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h2 id="vue中computed与方法和watch的区别"><a href="#vue中computed与方法和watch的区别" class="header-anchor">#</a> Vue中computed与方法和watch的区别</h2> <p>官方文档：<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="nofollow noopener noreferrer">计算属性与侦听器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>计算属性与方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'Temp'</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">'Hello'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">reversedMessage1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">reversedMessage2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><code>reversedMessage1</code>和<code>reversedMessage2()</code>得到的结果都是一样的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要<code>message</code>还没有发生改变，多次访问 <code>reversedMessage1</code>计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p> <p>计算属性与侦听器</p> <p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么Vue通过<code>watch</code>选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p> <p>区别</p> <ul><li><code>computed</code>是计算值，注重结果，并且会产生一个新的属性，与data里面的用法一样，<code>watch</code>是观察的动作，注重过程</li> <li>应用：<code>computed</code>就是简化<code>tempalte</code>里面<code>{{}}</code>计算和处理<code>props</code>或<code>$emit</code>的传值，<code>watch</code>监听<code>props</code>，<code>$emit</code>或本组件的值执行异步操作</li> <li><code>computed</code>具有缓存性，页面重新渲染值不变化，计算属性会立即返回之前的计算结果，而不必再次执行函数(getter)，<code>watch</code>不存在缓存，数据变化即执行</li> <li><code>computed</code>其实只是纯数据操作，需要返回数据结果，不建议在里面去修改外部的某个值，虽然使用了也没问题（可能eslint报错），如果有需要请使用<code>get</code>和<code>set</code>方法。但是<code>watch</code>就可以监测某个数据发生了变更进行一系列的回调操作，不仅仅局限于返回数据</li> <li><code>computed</code>会在vue实例化过程中执行一次(前提是这个计算属性在<code>template</code>有用到，如果没有用到，这个<code>computed</code>永远不会执行，包括vue初始化时)；<code>watch</code>在vue初始化时不会执行(除非设置<code>immediate: true</code>)，只会在监听的数据变化时执行</li> <li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是多对一或者一对一，一般用<code>computed</code>（应该不会用<code>watch</code>分别监听所有的属性来修改这一个属性吧）</li></ul> <h2 id="表单的readonly和disabled的区别"><a href="#表单的readonly和disabled的区别" class="header-anchor">#</a> 表单的readonly和disabled的区别</h2> <p>在表单元素中，<code>readonly</code>和<code>disable</code>有类似之处，因为它们都可以将一些表单元素设置为&quot;不可用&quot;状态，但还是有着明显的区别</p> <ol><li>设置两个属性的外观不一样，<code>readonly</code>外观没有变化，<code>disabled</code>会变灰。</li> <li><code>readonly</code>只是将元素设置为只读，其他操作正常，用户仍然可以使用<code>tab</code>键切换到该字段，还可以选中或拷贝其文本，而<code>disabled</code>阻止对元素的一切操作，例如获取焦点，点击事件等等。</li> <li><code>readonly</code>属性只对表单元素的<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>有效，但是<code>input</code>也只对输入框类型（<code>text/password/email/search/url/number</code>）、日期时间选择（<code>date/month/week/time/datetime/datetime-local</code>）有效，对按钮（<code>button/radio/checkbox/submin/reset</code>）、颜色（<code>color</code>）、滑块（<code>range</code>）、文件（<code>file</code>）、图片（<code>image</code>）都没有效果，依然可以操作。而<code>disabled</code>属性对所有的表单元素都会有效。</li> <li>表单提交时，设置<code>readonly</code>的表单元素value值依然会被提交，而设置<code>disabled</code>的表单元素值不会被提交。</li></ol> <p>element-ui的表单组件很多都是自己另外实现的，例如：</p> <ul><li><code>el-color-picker</code>：并不是用<code>input[type=&quot;color&quot;]</code>实现的，而是<code>div</code>背景颜色渐变，所以可用<code>readonly</code>控制</li> <li><code>el-input</code>给定<code>type=&quot;textarea&quot;</code>可以渲染成多行文本框，是内部判断渲染的<code>textarea</code>标签</li> <li><code>el-radio</code>和<code>el-checkbox</code>虽说内部都是原生<code>input</code>实现，但是<code>readonly</code>和<code>disabled</code>时是通过<code>v-if</code>控制渲染的另外的元素</li></ul> <h2 id="es5和es6中继承的区别"><a href="#es5和es6中继承的区别" class="header-anchor">#</a> ES5和ES6中继承的区别</h2> <ol><li><p>ES5里的构造函数就是一个普通的函数，可以使用<code>new</code>调用，也可以直接调用，而ES6的<code>class</code>不能当做普通函数直接调用，必须使用<code>new</code>操作符调用</p></li> <li><p>ES5的原型方法和静态方法默认是可枚举的，而<code>class</code>的静态方法默认不可枚举，静态属性是可枚举的，如果想要获取不可枚举的属性可以使用<code>Object.getOwnPropertyNames</code>方法</p></li> <li><p><code>class</code>的所有方法（包括静态方法和实例方法）都没有原型对象<code>prototype</code>，所以也没有<code>[[construct]]</code>，不能使用<code>new</code>来调用</p></li> <li><p>ES6子类可以直接通过<code>__proto__</code>找到父类，而ES5是指向<code>Function.prototype</code>：</p> <ul><li>ES6：<code>Sub.__proto__ === Sup</code></li> <li>ES5：<code>Sub.__proto__ === Function.prototype</code></li></ul></li> <li><p>ES5的继承，实质是先创造子类的实例对象<code>this</code>，然后再执行父类的构造函数给它添加实例方法和属性（不执行也无所谓）。而ES6的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（当然它的<code>__proto__</code>指向的是子类的<code>prototype</code>），然后再用子类的构造函数修改<code>this</code>。这就是为啥使用<code>class</code>继承在<code>constructor</code>函数里必须调用<code>super</code>，因为子类压根没有自己的<code>this</code>，另外不能在<code>super</code>执行前访问<code>this</code>的原因也很明显了，因为调用了<code>super</code>后，<code>this</code>才有值。</p></li> <li><p><code>class</code>不存在变量提升，所以父类必须在子类之前定义</p></li> <li><p><code>class</code>声明内部会启用严格模式</p></li></ol> <h2 id="以下3个判断数组的方法的区别和优劣"><a href="#以下3个判断数组的方法的区别和优劣" class="header-anchor">#</a> 以下3个判断数组的方法的区别和优劣</h2> <ul><li><p>Object.prototype.toString.call()</p> <p>每一个继承Object的对象都有<code>toString</code>方法，如果<code>toString</code>方法没有重写的话，会返回<code>[Object type]</code>，其中type为对象的类型。但当除了Object类型的对象外，其他类型直接使用<code>toString</code>方法时，会直接返回都是内容的字符串，所以我们需要使用<code>call</code>或者<code>apply</code>方法来改变<code>toString</code>方法的执行上下文。</p> <p>依赖于<code>Object.prototype.toString</code>并且<code>Function.prototype.call</code>没有被改变，并且<code>Symbol.toStringTag</code>没有被改变</p></li> <li><p>instanceof</p> <p>instanceof的内部机制是通过判断对象的原型链中是不是能找到类型的prototype。</p></li> <li><p>Array.isArray()</p> <ul><li>当检测Array实例时，<code>Array.isArray</code>优于<code>instanceof</code>，因为<code>Array.isArray</code>可以检测出iframes</li> <li><code>Array.isArray</code>是ES5新增的方法，当不存在<code>Array.isArray</code>，可以用<code>Object.prototype.toString.call</code>实现。</li></ul></li></ul> <p>如果是精心设计的假数组</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> fakeArray <span class="token operator">=</span> <span class="token punctuation">{</span>
  length<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  __proto__<span class="token operator">:</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'Array'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fakeArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Array]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fakeArray <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>fakeArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果是修改了真实数组的原型或者<code>Symbol.toStringTag</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> realArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
realArray<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Function'</span><span class="token punctuation">;</span>
realArray<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>realArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Function]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>realArray <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>realArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>另外还可以通过<code>arr.constructor === Array</code>来判断是不是数组，但是<code>constructor</code>会被修改，不能保证准确，所以<strong>非特殊情况首选</strong><code>Array.isArray</code></p> <h2 id="object-keys和object-getownpropertynames的区别"><a href="#object-keys和object-getownpropertynames的区别" class="header-anchor">#</a> Object.keys和Object.getOwnPropertyNames的区别</h2> <ul><li><code>Object.keys()</code>：返回<strong>对象自身</strong>的可枚举的属性的数组</li> <li><code>Object.getOwnPropertyNames()</code>：所有<strong>对象自身</strong>的属性名（包括不可枚举属性但不包括<code>Symbol</code>值作为名称的属性）的数组</li> <li><code>Object.getOwnPropertySymbols()</code>：返回一个包含<strong>给定对象</strong>所有<code>Symbol</code>属性的数组</li> <li><code>for...in</code>：以任意顺序迭代一个对象的除<code>Symbol</code>以外的可枚举属性，<strong>包括继承的可枚举属性</strong></li></ul> <h2 id="js中0-正零-0-和负零-0-的区别"><a href="#js中0-正零-0-和负零-0-的区别" class="header-anchor">#</a> JS中0,正零(+0)和负零(-0)的区别</h2> <ul><li><code>0 === +0 === -0</code>，三个中两两是严格相等的</li> <li><code>1/0 === 1/+0 === Infinity</code>（正的），<code>1/-0 === -Infinity</code>（负的）</li></ul> <h2 id="object-is-的区别"><a href="#object-is-的区别" class="header-anchor">#</a> Object.is,&quot;===&quot;,&quot;==&quot;的区别</h2> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="nofollow noopener noreferrer">JavaScript 中的相等性判断<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>使用<code>==</code>进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li> <li>使用<code>===</code>进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回<code>false</code>。</li> <li>使用<code>Object.is</code>来进行相等判断时，一般情况下和<code>===</code>的判断相同，它处理了一些特殊的情况，比如<code>-0</code>和<code>+0</code>不再相等，两个<code>NaN</code>是相等的。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>除了<code>===</code>之外，数组索引查找方法也使用严格相等，包括<code>Array.prototype.indexOf()</code>、<code>Array.prototype.lastIndexOf()</code>、<code>TypedArray.prototype.index()</code>、<code>TypedArray.prototype.lastIndexOf()</code>和<code>case</code>匹配。这意味着你不能使用<code>indexOf(NaN)</code>查找数组中<code>NaN</code>值的索引，也不能将<code>NaN</code>用作<code>case</code>值在<code>switch</code>语句中匹配任何内容。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>

<span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token number">NaN</span><span class="token operator">:</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Surprise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有任何输出</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>同值相等和零值相等</p> <ul><li>同值相等决定了两个值在所有上下文中是否在功能上相同。同值相等由<code>Object.is</code>方法提供。语言内部期望一个值等于另一个时，几乎所有地方都使用同值相等。</li> <li>零值相等，类似于同值相等，但<code>+0</code>和<code>-0</code>被视为相等。零值相等不作为JavaScript API公开，但可以通过自定义代码实现：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sameValueZero</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> y <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// x 和 y 相等（可能是 -0 和 0）或它们都是 NaN</span>
    <span class="token keyword">return</span> x <span class="token operator">===</span> y <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> x <span class="token operator">===</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>零值相等与严格相等的区别在于其将<code>NaN</code>视作是相等的，与同值相等的区别在于其将<code>-0</code>和<code>0</code>视作相等的。这使得它在搜索期间通常具有最实用的行为，特别是在与<code>NaN</code>一起使用时。它被用于<code>Array.prototype.includes()</code>、<code>TypedArray.prototype.includes()</code>及<code>Map</code>和<code>Set</code>方法用来比较键的相等性。</p> <h2 id="setimmediate和settimeout的区别"><a href="#setimmediate和settimeout的区别" class="header-anchor">#</a> setImmediate和setTimeout的区别</h2> <p><code>setImmediate</code>是一个用于在Node.js中执行异步操作的函数，会在当前事件循环的末尾立即执行回调函数，而不是等待一定的延迟时间。将回调函数放置在当前事件循环的队列末尾，以确保它在下一个事件循环开始时尽快执行，而不会阻塞其他任务。<code>setImmediate</code>的执行优先级比<code>setTimeout</code>高，因为它是在当前事件循环的末尾执行的，而<code>setTimeout</code>则要等待一定的延迟时间。两者都属于Macrotask。</p> <h2 id="eventsource和websocket"><a href="#eventsource和websocket" class="header-anchor">#</a> EventSource和WebSocket</h2> <ol><li><p><code>EventSource</code>是HTML5中新增的API，它提供了一种简单易用的方式来实现服务器向浏览器的即时推送。通过<code>EventSource</code>，我们可以建立一个持久连接，从而实现服务器端的事件推送到浏览器端。这使得我们能够轻松创建一个实时聊天室或实时数据展示页面。<code>EventSource</code>具有超高效、最好用的特点。它使用简单，只需要通过JavaScript代码创建一个<code>EventSource</code>对象，并指定服务器端的URL。然后，我们可以监听事件，处理服务器端发送的消息。最重要的是，<code>EventSource</code>基于HTTP协议，所以可以兼容大部分浏览器。</p> <p>优点：</p> <ul><li>简单易用，与HTTP协议兼容。</li> <li>只需要一个长连接，服务器可以推送任意数量的事件。</li> <li>适用于服务端向客户端发送频率较低的数据。</li> <li>可以自动重连，并且在连接断开时会触发<code>error</code>和<code>close</code>事件，方便处理异常情况。</li></ul> <p>缺点：</p> <ul><li>不支持双向通信。</li> <li>不支持二进制数据传输。</li> <li>兼容性存在问题，不支持IE浏览器。</li></ul></li> <li><p><code>WebSocket</code>与<code>EventSource</code>不同，<code>WebSocket</code>是一种全双工通信协议，它能够在浏览器和服务器之间建立双向通信的连接。相比于<code>EventSource</code>的单向通信，<code>WebSocket</code>可以同时实现浏览器向服务器的推送和服务器向浏览器的推送，实现真正的双向通信。<code>WebSocket</code>具有极低的延迟，适用于实时游戏、聊天应用等场景。它使用<code>ws</code>或<code>wss</code>协议，能够在浏览器和服务器之间建立长时间的连接。通过<code>WebSocket</code>，我们可以发送和接收消息，实时更新数据，并处理各种事件。</p> <p>优点:</p> <ul><li>支持双向通信，客户端和服务端都可以发送和接收消息。</li> <li>可以发送二进制数据，支持大文件传输。</li> <li>协议比较轻量级，能够节省网络带宽和服务器资源。</li> <li>兼容性较好，大部分现代浏览器都支持<code>WebSocket</code>。</li></ul> <p>缺点:</p> <ul><li>需要在服务端实现<code>WebSocket</code>协议的支持。</li> <li>相对于HTTP请求来说，<code>WebSocket</code>连接需要占用更多的服务端资源。</li> <li>安全性问题：需要注意防止CSRF和XSS攻击，避免恶意用户利用<code>WebSocket</code>劫持会话或注入脚本等。</li></ul></li></ol></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新: </span> <span class="time">2024年09月24日 17:39:40</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/pages/articles/interview/qian-duan-mian-shi-wang-luo-xiang-guan.html" class="prev">
            前端面试-网络相关
          </a></span> <span class="next"><a href="/pages/articles/interview/qian-duan-mian-shi-dai-ma-shu-chu.html">
            前端面试-代码输出
          </a></span></p></div> <div class="comments-wrapper" style="display:none;"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#箭头函数和普通函数的区别" class="sidebar-link reco-side-箭头函数和普通函数的区别" data-v-70334359>箭头函数和普通函数的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#var-let和const之间的区别" class="sidebar-link reco-side-var-let和const之间的区别" data-v-70334359>var,let和const之间的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#bigint和number的区别" class="sidebar-link reco-side-bigint和number的区别" data-v-70334359>Bigint和Number的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#基本数据类型和引用数据类型的区别" class="sidebar-link reco-side-基本数据类型和引用数据类型的区别" data-v-70334359>基本数据类型和引用数据类型的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#defer和async的区别" class="sidebar-link reco-side-defer和async的区别" data-v-70334359>defer和async的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#async-await对比promise的优缺点" class="sidebar-link reco-side-async-await对比promise的优缺点" data-v-70334359>async,await对比promise的优缺点</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#get和post的区别" class="sidebar-link reco-side-get和post的区别" data-v-70334359>GET和POST的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#用框架和不用框架的区别-vue和react的区别" class="sidebar-link reco-side-用框架和不用框架的区别-vue和react的区别" data-v-70334359>用框架和不用框架的区别,vue和react的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#cookies和session的区别" class="sidebar-link reco-side-cookies和session的区别" data-v-70334359>cookies和session的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#宏任务和微任务有什么区别" class="sidebar-link reco-side-宏任务和微任务有什么区别" data-v-70334359>宏任务和微任务有什么区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#fetch-ajax-axios区别" class="sidebar-link reco-side-fetch-ajax-axios区别" data-v-70334359>fetch,Ajax,axios区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#tcp和udp的区别" class="sidebar-link reco-side-tcp和udp的区别" data-v-70334359>TCP和UDP的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#js中的堆和栈-栈和队列有什么区别" class="sidebar-link reco-side-js中的堆和栈-栈和队列有什么区别" data-v-70334359>js中的堆和栈,栈和队列有什么区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#websocket和http有什么区别" class="sidebar-link reco-side-websocket和http有什么区别" data-v-70334359>WebSocket和HTTP有什么区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#http和https的区别" class="sidebar-link reco-side-http和https的区别" data-v-70334359>HTTP和HTTPS的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#px-em-rem-vw-vh区别" class="sidebar-link reco-side-px-em-rem-vw-vh区别" data-v-70334359>px,em,rem,vw,vh区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#bind-call-apply区别" class="sidebar-link reco-side-bind-call-apply区别" data-v-70334359>bind,call,apply区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#caller和callee的区别" class="sidebar-link reco-side-caller和callee的区别" data-v-70334359>caller和callee的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#_301和302有什么区别" class="sidebar-link reco-side-_301和302有什么区别" data-v-70334359>301和302有什么区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#进程线程协程的区别" class="sidebar-link reco-side-进程线程协程的区别" data-v-70334359>进程线程协程的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#javascript和typescript的区别" class="sidebar-link reco-side-javascript和typescript的区别" data-v-70334359>JavaScript和TypeScript的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#localstorage-sessionstorage-cookie的区别" class="sidebar-link reco-side-localstorage-sessionstorage-cookie的区别" data-v-70334359>localstorage,sessionstorage,cookie的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#http1-0-1-1-2-0的不同" class="sidebar-link reco-side-http1-0-1-1-2-0的不同" data-v-70334359>HTTP1.0/1.1/2.0的不同</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#mongodb和mysql的区别" class="sidebar-link reco-side-mongodb和mysql的区别" data-v-70334359>MongoDB和MySQL的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#width的100-与auto的区别" class="sidebar-link reco-side-width的100-与auto的区别" data-v-70334359>width的100%与auto的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#标准盒模型和怪异盒模型的区别" class="sidebar-link reco-side-标准盒模型和怪异盒模型的区别" data-v-70334359>标准盒模型和怪异盒模型的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#display-none和visibility-hidden和opacity-0的区别" class="sidebar-link reco-side-display-none和visibility-hidden和opacity-0的区别" data-v-70334359>display:none和visibility:hidden和opacity:0的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#sass和less的区别" class="sidebar-link reco-side-sass和less的区别" data-v-70334359>Sass和Less的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#sass中-include和-extend的区别" class="sidebar-link reco-side-sass中-include和-extend的区别" data-v-70334359>Sass中@include和@extend的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#css中link和-import的区别" class="sidebar-link reco-side-css中link和-import的区别" data-v-70334359>CSS中link和@import的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#浏览器和node事件循环的区别" class="sidebar-link reco-side-浏览器和node事件循环的区别" data-v-70334359>浏览器和Node事件循环的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#gif-jpg-png-webp的区别" class="sidebar-link reco-side-gif-jpg-png-webp的区别" data-v-70334359>gif,jpg,png,webp的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#isnan与number-isnan的区别" class="sidebar-link reco-side-isnan与number-isnan的区别" data-v-70334359>isNaN与Number.isNaN的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#观察者模式与发布订阅模式的区别" class="sidebar-link reco-side-观察者模式与发布订阅模式的区别" data-v-70334359>观察者模式与发布订阅模式的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#eslint和prettier的区别" class="sidebar-link reco-side-eslint和prettier的区别" data-v-70334359>ESLint和Prettier的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#正向代理和反向代理" class="sidebar-link reco-side-正向代理和反向代理" data-v-70334359>正向代理和反向代理</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#crlf-lf-cr的区别" class="sidebar-link reco-side-crlf-lf-cr的区别" data-v-70334359>CRLF,LF,CR的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#vue中computed与方法和watch的区别" class="sidebar-link reco-side-vue中computed与方法和watch的区别" data-v-70334359>Vue中computed与方法和watch的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#表单的readonly和disabled的区别" class="sidebar-link reco-side-表单的readonly和disabled的区别" data-v-70334359>表单的readonly和disabled的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#es5和es6中继承的区别" class="sidebar-link reco-side-es5和es6中继承的区别" data-v-70334359>ES5和ES6中继承的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#以下3个判断数组的方法的区别和优劣" class="sidebar-link reco-side-以下3个判断数组的方法的区别和优劣" data-v-70334359>以下3个判断数组的方法的区别和优劣</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#object-keys和object-getownpropertynames的区别" class="sidebar-link reco-side-object-keys和object-getownpropertynames的区别" data-v-70334359>Object.keys和Object.getOwnPropertyNames的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#js中0-正零-0-和负零-0-的区别" class="sidebar-link reco-side-js中0-正零-0-和负零-0-的区别" data-v-70334359>JS中0,正零(+0)和负零(-0)的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#object-is-的区别" class="sidebar-link reco-side-object-is-的区别" data-v-70334359>Object.is,&quot;===&quot;,&quot;==&quot;的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#setimmediate和settimeout的区别" class="sidebar-link reco-side-setimmediate和settimeout的区别" data-v-70334359>setImmediate和setTimeout的区别</a></li><li class="level-2" data-v-70334359><a href="/pages/articles/interview/qian-duan-mian-shi-xxyu-xxde-qu-bie.html#eventsource和websocket" class="sidebar-link reco-side-eventsource和websocket" data-v-70334359>EventSource和WebSocket</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:50%;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.3cc15c65.js" defer></script><script src="/assets/js/3.7300aef9.js" defer></script><script src="/assets/js/1.cfd142c1.js" defer></script><script src="/assets/js/65.ca037216.js" defer></script>
  </body>
</html>
