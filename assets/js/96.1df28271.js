(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{633:function(v,_,e){"use strict";e.r(_);var o=e(6),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("参考：")]),v._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.cnblogs.com/chip/p/4278135.html",target:"_blank",rel:"nofollow noopener noreferrer"}},[v._v("正则表达式的先行断言(lookahead)和后行断言(lookbehind)"),e("OutboundLink")],1)]),v._v(" "),e("li",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions",target:"_blank",rel:"nofollow noopener noreferrer"}},[v._v("Assertions"),e("OutboundLink")],1)])]),v._v(" "),e("p",[v._v("正则表达式的先行断言和后行断言一共有4种形式：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("x(?=y)")]),v._v("：零宽正向先行断言（zero-width positive lookahead assertion）（向前断言）：x被y跟随时匹配x，意思就是只有后面能匹配y时匹配x。")]),v._v(" "),e("li",[e("code",[v._v("x(?!y)")]),v._v("：零宽负向先行断言（zero-width negative lookahead assertion）（向前否定断言）：x没有被y紧随时匹配x，意思就是只有后面不能匹配y时匹配x。")]),v._v(" "),e("li",[e("code",[v._v("(?<=y)x")]),v._v("：零宽正向后行断言（zero-width positive lookbehind assertion）（向后断言）：x跟随y时匹配x，意思是只有x前面的能够匹配y时才匹配x。")]),v._v(" "),e("li",[e("code",[v._v("(?<!y)x")]),v._v("：零宽负向后行断言（zero-width negative lookbehind assertion）（向后否定断言）：x不跟随y时匹配x，意思是只有x前面的不能匹配y时匹配x。")])]),v._v(" "),e("p",[v._v("零宽断言正如它的名字一样，是一种零宽度的匹配，它匹配到的内容不会保存到匹配结果中去，最终匹配结果只是一个位置而已。")]),v._v(" "),e("p",[v._v("作用是给指定位置添加一个限定条件，用来规定此位置之前或者之后的字符必须满足限定条件才能使正则中的字表达式匹配成功。")]),v._v(" "),e("p",[v._v("对于这4个断言的理解，可以从两个方面入手：")]),v._v(" "),e("ol",[e("li",[v._v("关于先行（lookahead）和后行（lookbehind）：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。")]),v._v(" "),e("li",[v._v("关于正向（positive）和负向（negative）：正向就表示匹配括号中的表达式，负向表示不匹配。")])]),v._v(" "),e("p",[v._v("对这4个断言形式的记忆：")]),v._v(" "),e("ol",[e("li",[v._v("先行和后行：后行断言"),e("code",[v._v("(?<=y)x")]),v._v("、"),e("code",[v._v("(?<!y)x")]),v._v("中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。")]),v._v(" "),e("li",[v._v("正向和负向：不等于"),e("code",[v._v("!=")]),v._v("、逻辑非"),e("code",[v._v("!")]),v._v("都是用"),e("code",[v._v("!")]),v._v("号来表示，所以有"),e("code",[v._v("!")]),v._v("号的形式表示不匹配、负向；将"),e("code",[v._v("!")]),v._v("号换成"),e("code",[v._v("=")]),v._v("号，就表示匹配、正向。")])]),v._v(" "),e("p",[v._v("上述4种断言，括号里的"),e("code",[v._v("y")]),v._v("本身是一个正则表达式。但对2种后行断言有所限制，在Perl和Python中，这个表达式必须是定长（fixed length）的，即不能使用"),e("code",[v._v("*")]),v._v("、"),e("code",[v._v("+")]),v._v("、"),e("code",[v._v("?")]),v._v("等元字符，如"),e("code",[v._v("(?<=abc)")]),v._v("没有问题，但"),e("code",[v._v("(?<=a*bc)")]),v._v("是不被支持的，特别是当表达式中含有"),e("code",[v._v("|")]),v._v("连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持"),e("code",[v._v("?")]),v._v("、"),e("code",[v._v("{m}")]),v._v("、"),e("code",[v._v("{n,m}")]),v._v("等符号，但同样不支持"),e("code",[v._v("*")]),v._v("、"),e("code",[v._v("+")]),v._v("字符。Javascript干脆不支持后行断言，不过一般来说，这不是太大的问题（"),e("strong",[v._v("ES2018引入后行断言，V8引擎4.9版（Chrome 62）已经支持。")]),v._v("）")]),v._v(" "),e("p",[v._v("其他边界类断言")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("字符")]),v._v(" "),e("th",[v._v("含义")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[e("code",[v._v("^")])]),v._v(" "),e("td",[v._v("匹配输入的开头。如果多行模式设为true，"),e("code",[v._v("^")]),v._v("在换行符后也能立即匹配。"),e("code",[v._v("^")]),v._v("出现在集合或范围开头时的含义与此不同。")])]),v._v(" "),e("tr",[e("td",[e("code",[v._v("$")])]),v._v(" "),e("td",[v._v("匹配输入的结束。如果多行模式设为true，"),e("code",[v._v("$")]),v._v("在换行符前也能立即匹配。")])]),v._v(" "),e("tr",[e("td",[e("code",[v._v("\\b")])]),v._v(" "),e("td",[v._v("匹配一个单词的边界，这是一个字的字符前后没有另一个字的字符位置，例如在字母和空格之间。需要注意的是匹配的单词边界不包括在匹配中。换句话说，匹配字边界的长度为零。")])]),v._v(" "),e("tr",[e("td",[e("code",[v._v("\\B")])]),v._v(" "),e("td",[v._v("匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);