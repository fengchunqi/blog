(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{586:function(t,s,a){"use strict";a.r(s);var n=a(6),v=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("参考文章："),a("a",{attrs:{href:"https://github.com/chenjigeng/blog/issues/4",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("你真的了解回流和重绘吗"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"浏览器渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[t._v("#")]),t._v(" 浏览器渲染过程")]),t._v(" "),a("ul",[a("li",[t._v("解析HTML，生成DOM树，解析CSS，生成CSSOM树")]),t._v(" "),a("li",[t._v("将DOM树和CSSOM树结合，生成渲染树(Render Tree)，渲染树只包含渲染网页所需的节点。")]),t._v(" "),a("li",[t._v("Layout(回流)：根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）（chrome的Performance中就叫layout和paint）")]),t._v(" "),a("li",[t._v("Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素")]),t._v(" "),a("li",[t._v("Display：将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层）")])]),t._v(" "),a("p",[t._v("为构建渲染树，浏览器大体上完成了下列工作:")]),t._v(" "),a("ul",[a("li",[t._v("从DOM树的根节点开始遍历每个可见节点。")]),t._v(" "),a("li",[t._v("对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。")]),t._v(" "),a("li",[t._v("根据每个可见节点以及其对应的样式，组合生成渲染树。")])]),t._v(" "),a("p",[t._v("不可见的节点包括：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("一些不会渲染输出的节点，比如"),a("code",[t._v("script")]),t._v("、"),a("code",[t._v("meta")]),t._v("、"),a("code",[t._v("link")]),t._v("等。")])]),t._v(" "),a("li",[a("p",[t._v("一些通过css进行隐藏的节点。比如"),a("code",[t._v("display:none")]),t._v("。注意，利用"),a("code",[t._v("visibility")]),t._v("和"),a("code",[t._v("opacity")]),t._v("隐藏的节点，还是会显示在渲染树上的。只有"),a("code",[t._v("display:none")]),t._v("的节点才不会显示在渲染树上。")])]),t._v(" "),a("li",[a("p",[t._v("重排（Reflow）（又叫回流）：构造渲染树，将可见DOM节点以及它对应的样式结合起来，可是还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。")])]),t._v(" "),a("li",[a("p",[t._v("重绘（Repaint）：构造渲染树和回流阶段，知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。")])])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("重排必定为触发重绘，但重绘不一定触发重排。")])]),t._v(" "),a("h2",{attrs:{id:"何时发生回流重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时发生回流重绘"}},[t._v("#")]),t._v(" 何时发生回流重绘")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("页面首次渲染")])]),t._v(" "),a("li",[a("p",[t._v("浏览器窗口大小发生改变")])]),t._v(" "),a("li",[a("p",[t._v("元素尺寸或位置发生改变元素内容变化（文字数量或图片大小等等）")])]),t._v(" "),a("li",[a("p",[t._v("元素字体大小变化")])]),t._v(" "),a("li",[a("p",[t._v("添加或者删除可见的DOM元素")])]),t._v(" "),a("li",[a("p",[t._v("激活CSS伪类（例如:hover）")])]),t._v(" "),a("li",[a("p",[t._v("一些常用且会导致回流的属性和方法，因为这些都要去计算位置或大小")]),t._v(" "),a("ul",[a("li",[t._v("clientWidth")]),t._v(" "),a("li",[t._v("clientHeight")]),t._v(" "),a("li",[t._v("clientTop")]),t._v(" "),a("li",[t._v("clientLeft")]),t._v(" "),a("li",[t._v("offsetWidth")]),t._v(" "),a("li",[t._v("offsetHeight")]),t._v(" "),a("li",[t._v("offsetTop")]),t._v(" "),a("li",[t._v("offsetLeft")]),t._v(" "),a("li",[t._v("scrollWidth")]),t._v(" "),a("li",[t._v("scrollHeight")]),t._v(" "),a("li",[t._v("scrollTop")]),t._v(" "),a("li",[t._v("scrollLeft")]),t._v(" "),a("li",[t._v("scrollIntoView()")]),t._v(" "),a("li",[t._v("scrollIntoViewIfNeeded()")]),t._v(" "),a("li",[t._v("scrollTo()")]),t._v(" "),a("li",[t._v("getComputedStyle()")]),t._v(" "),a("li",[t._v("getBoundingClientRect()")])])])]),t._v(" "),a("h2",{attrs:{id:"减少回流和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少回流和重绘"}},[t._v("#")]),t._v(" 减少回流和重绘")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("最小化重绘和重排")]),t._v(" "),a("p",[t._v("由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'test'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("padding "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'5px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderLeft "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderRight "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 大部分现代浏览器都对其做了优化，因此，只会触发一次重排。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是如果在旧版的浏览器或者在上面代码执行的时候，")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以合并所有的改变")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用cssText")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cssText "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'border-left: 1px; border-right: 2px; padding: 5px;'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 修改CSS的class")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("className "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("' active'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("批量修改DOM")]),t._v(" "),a("p",[t._v("当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：")]),t._v(" "),a("ul",[a("li",[t._v("使元素脱离文档流 => 对其进行多次修改 => 将元素带回到文档中")])]),t._v(" "),a("p",[t._v("该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。")]),t._v(" "),a("p",[t._v("有三种方式可以让DOM脱离文档流：")]),t._v(" "),a("ul",[a("li",[t._v("隐藏元素，应用修改，重新显示")]),t._v(" "),a("li",[t._v("使用文档片段(document fragment，"),a("code",[t._v("document.createDocumentFragment")]),t._v(")在当前DOM之外构建一个子树，再把它拷贝回文档。")]),t._v(" "),a("li",[t._v("将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。")])])]),t._v(" "),a("li",[a("p",[t._v("避免触发同步布局事件")]),t._v(" "),a("p",[t._v("访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。")])]),t._v(" "),a("li",[a("p",[t._v("对于复杂动画效果,使用绝对定位让其脱离文档流")]),t._v(" "),a("p",[t._v("对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。")])]),t._v(" "),a("li",[a("p",[t._v("css3硬件加速（GPU加速）")]),t._v(" "),a("ul",[a("li",[t._v("使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘")]),t._v(" "),a("li",[t._v("对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。")])]),t._v(" "),a("p",[t._v("css3硬件加速的坑")]),t._v(" "),a("ul",[a("li",[t._v("如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。")]),t._v(" "),a("li",[t._v("在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。可能CSS3的动画会产生字体模糊。")])]),t._v(" "),a("p",[t._v("常见的触发硬件加速的css属性（最好用transform，animations）：")]),t._v(" "),a("ul",[a("li",[t._v("transform")]),t._v(" "),a("li",[t._v("animations")]),t._v(" "),a("li",[t._v("transition")]),t._v(" "),a("li",[t._v("opacity")]),t._v(" "),a("li",[t._v("filters")]),t._v(" "),a("li",[t._v("Will-change")])])])])])}),[],!1,null,null,null);s.default=v.exports}}]);