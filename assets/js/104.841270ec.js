(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{642:function(t,e,a){"use strict";a.r(e);var s=a(6),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("code",[t._v("setState")]),t._v("将组件的"),a("code",[t._v("state")]),t._v("的更改加入队列。它告诉React该组件及其子组件需要使用新的"),a("code",[t._v("state")]),t._v("来重新渲染。调用"),a("code",[t._v("setState")]),t._v("时不会更改已执行代码中当前的"),a("code",[t._v("state")]),t._v("，它只影响从下一个渲染开始返回的"),a("code",[t._v("this.state")]),t._v("。")]),t._v(" "),a("p",[t._v("参数")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("nextState")]),t._v("：一个对象或者函数。")]),t._v(" "),a("ul",[a("li",[t._v("如果你传递一个对象作为"),a("code",[t._v("nextState")]),t._v("，它将浅层合并到"),a("code",[t._v("this.state")]),t._v("中。")]),t._v(" "),a("li",[t._v("如果你传递一个函数作为"),a("code",[t._v("nextState")]),t._v("，它将被视为更新函数。它必须是个纯函数，应该以已加载的"),a("code",[t._v("state")]),t._v("和"),a("code",[t._v("props")]),t._v("作为参数，并且应该返回要浅层合并到"),a("code",[t._v("this.state")]),t._v("中的对象。React会将你的更新函数放入队列中并重新渲染你的组件。在下一次渲染期间，React将通过应用队列中的所有的更新函数来计算下一个"),a("code",[t._v("state")]),t._v("。")])])]),t._v(" "),a("li",[a("p",[t._v("可选的"),a("code",[t._v("callback")]),t._v("：如果你指定该函数，React将在提交更新后调用你提供的"),a("code",[t._v("callback")]),t._v("。")])])]),t._v(" "),a("p",[t._v("注意")]),t._v(" "),a("ul",[a("li",[t._v("将"),a("code",[t._v("setState")]),t._v("视为请求而不是立即更新组件的命令。当多个组件更新它们的"),a("code",[t._v("state")]),t._v("来响应事件时，React将批量更新它们，并在这次事件结束时将它们一并重新渲染。在极少数情况下，你需要强制同步应用特定的"),a("code",[t._v("state")]),t._v("更新，这时你可以将其包装在"),a("code",[t._v("flushSync")]),t._v("中，但这可能会损害性能。")]),t._v(" "),a("li",[a("code",[t._v("setState")]),t._v("不会立即更新"),a("code",[t._v("this.state")]),t._v("。这让在调用"),a("code",[t._v("setState")]),t._v("之后立即读取"),a("code",[t._v("setState")]),t._v("成为了一个潜在的陷阱。相反请使用"),a("code",[t._v("componentDidUpdate")]),t._v("或设置"),a("code",[t._v("setState")]),t._v("的"),a("code",[t._v("callback")]),t._v("参数，其中任何一个都保证读取"),a("code",[t._v("state")]),t._v("将在"),a("code",[t._v("state")]),t._v("的更新后触发。如果需要根据前一个"),a("code",[t._v("state")]),t._v("来设置"),a("code",[t._v("state")]),t._v("，那么可以传递给"),a("code",[t._v("nextState")]),t._v("一个函数。")])]),t._v(" "),a("p",[t._v("在react源码中他是同步的方法，通过队列的形式更新state的值，因此展现给人是异步更新的状态，但实际上它是一个同步的方法。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("同步的情况（React17及之前的版本）")]),t._v(" "),a("ul",[a("li",[t._v("在"),a("code",[t._v("setTimeout")]),t._v("中是同步的。")]),t._v(" "),a("li",[t._v("在原生事件中是同步的，即通过dom绑定事件的方式实现（"),a("code",[t._v("element.addEventListener()")]),t._v("）。")])])]),t._v(" "),a("li",[a("p",[t._v("异步的情况")]),t._v(" "),a("ul",[a("li",[t._v("在合成事件中是异步的，这里说的异步实际上是react的批量更新，达到了提升性能的目的。")]),t._v(" "),a("li",[t._v("在生命周期中是异步的。")])])])]),t._v(" "),a("p",[t._v("在React17及之前的版本，"),a("code",[t._v("setState")]),t._v("在"),a("code",[t._v("setTimeout")]),t._v("等异步函数和原生事件内是同步执行的，在18版本之后是批量更新的。React17可以通过"),a("code",[t._v("ReactDOM.unstable_batchedUpdates")]),t._v("来实现批量更新"),a("code",[t._v("state")]),t._v("。")]),t._v(" "),a("p",[t._v("执行流程：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("首先将"),a("code",[t._v("setState")]),t._v("中的参数"),a("code",[t._v("nextState")]),t._v("存储到"),a("code",[t._v("pendingState")]),t._v("暂存队列中。")])]),t._v(" "),a("li",[a("p",[t._v("判断当前React是否处于批量处理状态：")]),t._v(" "),a("ul",[a("li",[t._v("是：则将组件推入待更新队列（"),a("code",[t._v("dirtyComponents")]),t._v("）。")]),t._v(" "),a("li",[t._v("不是：则设置更新批量处理状态为"),a("code",[t._v("ture")]),t._v("，然后再将组件推入待更新队列（批量更新完成后，设置批量处理状态为"),a("code",[t._v("false")]),t._v("，执行事务步骤）。")])])]),t._v(" "),a("li",[a("p",[t._v("调用事务（Transaction）"),a("code",[t._v("wapper")]),t._v("方法遍历组件待更新队列"),a("code",[t._v("dirtyComponents")]),t._v("，执行更新。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("componentWillRecevieProps")]),t._v("执行。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("state")]),t._v("暂存队列合并，获取最终要更新的"),a("code",[t._v("state")]),t._v("，队列置空（ps：函数参数也是在这里确定值获取到"),a("code",[t._v("prevState")]),t._v("）。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("assign")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" partial "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'function'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("partial")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("inst"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" context"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" partial"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("componentShouldUpdate")]),t._v("执行，根据返回值判断是否更新。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("componentWillUpdate")]),t._v("执行。")])]),t._v(" "),a("li",[a("p",[t._v("执行真正的更新："),a("code",[t._v("render")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("componentDidUpdate")]),t._v("执行。")])])]),t._v(" "),a("p",[t._v("最简单的话来讲就是"),a("code",[t._v("state")]),t._v("接收到一个新状态不会被立即执行，而是会被推入到"),a("code",[t._v("pendingState")]),t._v("队列（Queue）中，随后判断"),a("code",[t._v("isBatchingUpdates")]),t._v("的值，为"),a("code",[t._v("true")]),t._v("，则将新状态保存到"),a("code",[t._v("dirtyComponents")]),t._v("（脏组件）中；为"),a("code",[t._v("false")]),t._v("的话，遍历"),a("code",[t._v("dirtyComponents")]),t._v("，并调用"),a("code",[t._v("updateComponent")]),t._v("方法更新"),a("code",[t._v("pengdingState")]),t._v("中的"),a("code",[t._v("state")]),t._v("或"),a("code",[t._v("props")]),t._v("，将队列初始化。")]),t._v(" "),a("p",[t._v("React的更新是基于Transaction（事务）的，Transacation就是给目标执行的函数包裹一下，加上前置和后置的hook（有点类似koa的middleware），在开始执行之前先执行"),a("code",[t._v("initialize hook")]),t._v("，结束之后再执行"),a("code",[t._v("close hook")]),t._v("，这样搭配上"),a("code",[t._v("isBatchingUpdates")]),t._v("这样的布尔标志位就可以实现一整个函数调用栈内的多次"),a("code",[t._v("setState")]),t._v("全部入"),a("code",[t._v("pending")]),t._v("队列，结束后统一apply了。\n但是"),a("code",[t._v("setTimeout")]),t._v("这样的方法执行是脱离了事务的，react管控不到，所以就没法batch了。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("钩子函数和合成事件中")]),t._v(" "),a("p",[t._v("在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时"),a("code",[t._v("isBatchingUpdates")]),t._v("为"),a("code",[t._v("true")]),t._v("。按照上述过程，这时无论调用多少次"),a("code",[t._v("setState")]),t._v("，都会不会执行更新，而是将要更新的"),a("code",[t._v("state")]),t._v("存入"),a("code",[t._v("_pendingStateQueue")]),t._v("，将要更新的组件存入"),a("code",[t._v("dirtyComponent")]),t._v("。当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件DidMount后会将"),a("code",[t._v("isBatchingUpdates")]),t._v("设置为"),a("code",[t._v("false")]),t._v("。这时将执行之前累积的"),a("code",[t._v("setState")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("异步函数和原生事件中")]),t._v(" "),a("p",[t._v("由执行机制看，"),a("code",[t._v("setState")]),t._v("本身并不是异步的，而是如果在调用"),a("code",[t._v("setState")]),t._v("时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，"),a("code",[t._v("isBatchingUpdates")]),t._v("被设置为"),a("code",[t._v("false")]),t._v("，根据上面的流程，这时再调用"),a("code",[t._v("setState")]),t._v("即可立即执行更新，拿到更新结果。")])])]),t._v(" "),a("p",[t._v("如何获取到上一次的"),a("code",[t._v("state")]),t._v("的值？")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ClassComponent")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("prevState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" props")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// FunctionComponent")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setCount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("prev")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("参考文章")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/64a05458d7b1",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("setState是同步还是异步"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/qq_39207948/article/details/113803273",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("React中setState更新机制、batchUpdate机制和transaction事务机制"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);